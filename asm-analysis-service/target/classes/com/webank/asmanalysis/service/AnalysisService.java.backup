package com.webank.asmanalysis.service;

import com.webank.asmanalysis.asm.ClassAnalyzer;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Service layer for ASM bytecode analysis.
 * Contains business logic migrated from the original ASMAnalysisService.
 */
@Service
public class AnalysisService {
    private static final Logger logger = LoggerFactory.getLogger(AnalysisService.class);
    private static final ObjectMapper mapper = new ObjectMapper();

    /**
     * Analyze class files from given directories or files
     *
     * Request body (Option 1 - Package Roots):
     * {
     *   "packageRoots": ["/path/to/package1", "/path/to/package2"],
     *   "limit": 100  // optional
     * }
     *
     * Request body (Option 2 - Explicit Paths):
     * {
     *   "classDirs": ["/path/to/classes1", "/path/to/classes2"],
     *   "mapping": {
     *     "/path/to/classes1": "/path/to/sources1",
     *     "/path/to/classes2": "/path/to/sources2"
     *   },
     *   "limit": 100  // optional
     * }
     *
     * Request body (Option 3 - Individual Class Files):
     * {
     *   "classFiles": ["/path/to/MyClass.class", "/path/to/OtherClass.class"],
     *   "mapping": {
     *     "/path/to/classes": "/path/to/sources"
     *   },
     *   "domains": ["com.example.apps", "com.example"],  // optional: filter classes by FQN prefix
     *   "limit": 100  // optional
     * }
     */
    public Map<String, Object> analyze(Map<String, Object> request) throws IOException {
        List<String> classDirs = new ArrayList<>();
        Map<String, String> mapping = new HashMap<>();
        List<Path> classFiles = new ArrayList<>();
        logger.info("[ANALYSIS_START] analyze method called with request keys: {}", request.keySet());

        // Option 1: packageRoots (auto-discover classes/ and sources/)
        // Also extract packageName from path if not provided
        String autoDetectedPackageName = null;
        if (request.containsKey("packageRoots")) {
            @SuppressWarnings("unchecked")
            List<String> packageRoots = (List<String>) request.get("packageRoots");

            for (String packageRoot : packageRoots) {
                Path rootPath = Paths.get(packageRoot);

                // Extract package name from directory name (e.g., "example-core-1.0.0")
                if (autoDetectedPackageName == null) {
                    autoDetectedPackageName = rootPath.getFileName().toString();
                }

                Path classesPath = rootPath.resolve("classes");
                Path sourcesPath = rootPath.resolve("sources");

                if (Files.exists(classesPath) && Files.isDirectory(classesPath)) {
                    // Normalize path separator to forward slash for cross-platform compatibility
                    classDirs.add(classesPath.toString().replace('\\', '/'));

                    // Add mapping if sources exist
                    if (Files.exists(sourcesPath) && Files.isDirectory(sourcesPath)) {
                        mapping.put(classesPath.toString().replace('\\', '/'), sourcesPath.toString().replace('\\', '/'));
                    }
                } else {
                    logger.warn("Warning: classes/ not found in {}", packageRoot);
                }
            }
        }
        // Option 2: explicit classDirs (backward compatibility)
        else if (request.containsKey("classDirs")) {
            @SuppressWarnings("unchecked")
            List<String> explicitClassDirs = (List<String>) request.get("classDirs");
            // Normalize path separators to forward slash for cross-platform compatibility
            for (String dir : explicitClassDirs) {
                classDirs.add(dir.replace('\\', '/'));
            }

            if (request.containsKey("mapping")) {
                @SuppressWarnings("unchecked")
                Map<String, String> explicitMapping = (Map<String, String>) request.get("mapping");
                // Normalize path separators to forward slash for cross-platform compatibility
                for (Map.Entry<String, String> entry : explicitMapping.entrySet()) {
                    mapping.put(entry.getKey().replace('\\', '/'), entry.getValue().replace('\\', '/'));
                }
            }
        }
        // Option 3: explicit class files
        else if (request.containsKey("classFiles")) {
            @SuppressWarnings("unchecked")
            List<String> explicitClassFiles = (List<String>) request.get("classFiles");

            for (String classFilePath : explicitClassFiles) {
                // Normalize path separator before creating Path
                String normalizedPath = classFilePath.replace('\\', '/');
                Path path = Paths.get(normalizedPath);
                if (Files.exists(path) && normalizedPath.endsWith(".class")) {
                    classFiles.add(path);
                } else {
                    logger.warn("Warning: invalid class file: {}", normalizedPath);
                }
            }

            if (request.containsKey("mapping")) {
                @SuppressWarnings("unchecked")
                Map<String, String> explicitMapping = (Map<String, String>) request.get("mapping");
                // Normalize path separators to forward slash for cross-platform compatibility
                for (Map.Entry<String, String> entry : explicitMapping.entrySet()) {
                    mapping.put(entry.getKey().replace('\\', '/'), entry.getValue().replace('\\', '/'));
                }
            }
        } else {
            throw new IllegalArgumentException("Either packageRoots, classDirs, or classFiles is required");
        }

        Integer limit = request.containsKey("limit") ?
            ((Number) request.get("limit")).intValue() : null;

        // Get domains for filtering (default to empty list)
        List<String> domains = new ArrayList<>();
        if (request.containsKey("domains")) {
            @SuppressWarnings("unchecked")
            List<String> domainsList = (List<String>) request.get("domains");
            domains.addAll(domainsList);
        }

        // Get packageName: use provided or auto-detected from packageRoots
        String packageName = request.containsKey("packageName") ?
            (String) request.get("packageName") : autoDetectedPackageName;

        // Collect all .class files if not already provided
        if (classFiles.isEmpty()) {
            if (classDirs.isEmpty()) {
                throw new IllegalArgumentException("No valid class directories or files found");
            }

            for (String dirPath : classDirs) {
                Path dir = Paths.get(dirPath);
                if (Files.exists(dir) && Files.isDirectory(dir)) {
                    Files.walk(dir)
                        .filter(p -> p.toString().endsWith(".class"))
                        .forEach(classFiles::add);
                }
            }
        }

        // Apply limit if specified
        if (limit != null && classFiles.size() > limit) {
            classFiles = classFiles.subList(0, limit);
        }

        logger.info("Analyzing {} class files", classFiles.size());

        // Analyze files
        List<Map<String, Object>> nodes = new ArrayList<>();
        List<Map<String, Object>> edges = new ArrayList<>();

        for (Path classFile : classFiles) {
            try {
                ClassAnalyzer analyzer = new ClassAnalyzer(classFile);
                analyzer.analyze();

                nodes.addAll(analyzer.getNodes());
                edges.addAll(analyzer.getEdges());
            } catch (Exception e) {
                logger.error("Failed to analyze {}: {}", classFile, e.getMessage(), e);
            }
        }

        // Group data by class for readable structure
        Map<String, Map<String, Object>> classByFqn = new HashMap<>();

        // Step 1: Build class nodes
        // Define fields to exclude from automatic copying (already handled specially)
        // Note: "methods", "fields", "inheritance", "constructorInjections" are initialized separately
        Set<String> CLASS_EXCLUDED_FIELDS = new HashSet<>(Arrays.asList(
            "nodeType", "fqn",
            "methods", "fields", "inheritance", "constructorInjections"));

        for (Map<String, Object> node : nodes) {
            String nodeType = (String) node.get("nodeType");
            String fqn = (String) node.get("fqn");

            // Filter classes by domain - DISABLED for complete call graph
            if ("class".equals(nodeType) || "interface".equals(nodeType) || "enum".equals(nodeType)) {
                // if (!matchesDomainFilter(fqn, domains)) {
                //     continue; // Skip non-matching classes
                // }

                Map<String, Object> classData = new HashMap<>();
                // Initialize structure fields
                classData.put("methods", new ArrayList<Map<String, Object>>());
                classData.put("fields", new ArrayList<Map<String, Object>>());
                classData.put("inheritance", new ArrayList<Map<String, Object>>());
                classData.put("constructorInjections", new ArrayList<Map<String, Object>>());

                // Add essential identification fields
                classData.put("fqn", fqn);
                classData.put("nodeType", nodeType);

                // Copy all fields from node except excluded ones
                for (Map.Entry<String, Object> entry : node.entrySet()) {
                    String key = entry.getKey();
                    if (!CLASS_EXCLUDED_FIELDS.contains(key)) {
                        classData.put(key, entry.getValue());
                    }
                }

                classByFqn.put(fqn, classData);
            }
        }

        // Step 2: Add methods to their classes
        // Define fields to exclude from automatic copying (already handled specially)
        // Note: "arguments", "calls" are initialized separately
        Set<String> METHOD_EXCLUDED_FIELDS = new HashSet<>(Arrays.asList(
            "nodeType", "fqn",
            "arguments", "calls"));

        // Define fields to exclude from edge copying (already handled specially)
        // Note: "edgeType" identifies the edge type, "fromFqn" is used to find the calling method
        Set<String> EDGE_EXCLUDED_FIELDS = new HashSet<>(Arrays.asList(
            "edgeType", "fromFqn"));

        Map<String, Map<String, Object>> methodByFqn = new HashMap<>();
        for (Map<String, Object> node : nodes) {
            String nodeType = (String) node.get("nodeType");
            if ("method".equals(nodeType)) {
                String methodFqn = (String) node.get("fqn");

                // Extract class FQN from method FQN
                // Find the '.' before the method name, not in the parameter types
                int paramStart = methodFqn.indexOf('(');
                if (paramStart == -1) {
                    logger.warn("[FQN_PARSE_ERROR] Skipping malformed method FQN (no '(' found): {}", methodFqn);
                    continue;
                }
                int methodSep = methodFqn.lastIndexOf('.', paramStart);
                if (methodSep == -1) {
                    logger.warn("[FQN_PARSE_ERROR] Skipping malformed method FQN (no '.' before '('): {}", methodFqn);
                    continue;
                }
                String classFqn = methodFqn.substring(0, methodSep);

                Map<String, Object> classData = classByFqn.get(classFqn);
                if (classData == null) continue; // Method's class was filtered out

                Map<String, Object> methodData = new HashMap<>();
                // Initialize structure fields
                methodData.put("arguments", new ArrayList<String>());
                methodData.put("calls", new ArrayList<Map<String, Object>>());

                // Add essential identification field
                methodData.put("fqn", methodFqn);

                // Copy all fields from node except excluded ones
                for (Map.Entry<String, Object> entry : node.entrySet()) {
                    String key = entry.getKey();
                    if (!METHOD_EXCLUDED_FIELDS.contains(key)) {
                        methodData.put(key, entry.getValue());
                    }
                }

                @SuppressWarnings("unchecked")
                List<Map<String, Object>> methods = (List<Map<String, Object>>) classData.get("methods");
                methods.add(methodData);

                methodByFqn.put(methodFqn, methodData);
            }
        }

        // Step 3: Process edges
        for (Map<String, Object> edge : edges) {
            String edgeType = (String) edge.get("edgeType");

            if ("inheritance".equals(edgeType)) {
                // Add to class inheritance
                String fromFqn = (String) edge.get("fromFqn");
                Map<String, Object> classData = classByFqn.get(fromFqn);
                if (classData != null) {
                    Map<String, Object> inhData = new HashMap<>();
                    inhData.put("fqn", edge.get("toFqn"));
                    inhData.put("kind", edge.get("kind"));

                    @SuppressWarnings("unchecked")
                    List<Map<String, Object>> inheritance = (List<Map<String, Object>>) classData.get("inheritance");
                    inheritance.add(inhData);
                }
            } else if ("call".equals(edgeType)) {
                // Add to method calls
                String fromFqn = (String) edge.get("fromFqn");
                Map<String, Object> methodData = methodByFqn.get(fromFqn);
                if (methodData != null) {
                    Map<String, Object> callData = new HashMap<>();

                    // [FIX] 动态拷贝所有属性 (包含 lambda_name, descriptor, bootstrap_info 等)
                    for (Map.Entry<String, Object> entry : edge.entrySet()) {
                        if (!EDGE_EXCLUDED_FIELDS.contains(entry.getKey())) {
                            callData.put(entry.getKey(), entry.getValue());
                        }
                    }

                    @SuppressWarnings("unchecked")
                    List<Map<String, Object>> calls = (List<Map<String, Object>>) methodData.get("calls");
                    calls.add(callData);
                }
            } else if ("member_of".equals(edgeType)) {
                String kind = (String) edge.get("kind");
                String fromFqn = (String) edge.get("fromFqn"); // The type
                String toFqn = (String) edge.get("toFqn");     // The container

                if ("return".equals(kind)) {
                    // Return type of a method
                    Map<String, Object> methodData = methodByFqn.get(toFqn);
                    if (methodData != null) {
                        methodData.put("returnType", fromFqn);
                    }
                } else if ("argument".equals(kind)) {
                    // Argument type of a method
                    Map<String, Object> methodData = methodByFqn.get(toFqn);
                    if (methodData != null) {
                        @SuppressWarnings("unchecked")
                        List<String> arguments = (List<String>) methodData.get("arguments");
                        arguments.add(fromFqn);
                    }
                } else if (kind != null && (kind.equals("class") || kind.startsWith("class:"))) {
                    // Field type of a class
                    // Extract class FQN from toFqn (which is the class)
                    Map<String, Object> classData = classByFqn.get(toFqn);
                    if (classData != null) {
                        Map<String, Object> fieldData = new HashMap<>();
                        fieldData.put("type", fromFqn);

                        // Extract injection type if present (e.g., "class:autowired" -> "autowired")
                        if (kind.startsWith("class:")) {
                            String injectionType = kind.substring(6); // Remove "class:" prefix
                            fieldData.put("injectionType", injectionType);

                            // Add qualifier if present
                            if (edge.containsKey("qualifier")) {
                                fieldData.put("qualifier", edge.get("qualifier"));
                            }
                        }

                        @SuppressWarnings("unchecked")
                        List<Map<String, Object>> fields = (List<Map<String, Object>>) classData.get("fields");
                        fields.add(fieldData);
                    }
                } else if (kind != null && kind.startsWith("constructor:")) {
                    // Constructor injection
                    // Extract class FQN from toFqn (which is the class)
                    Map<String, Object> classData = classByFqn.get(toFqn);
                    if (classData != null) {
                        // Store constructor injection info in class data
                        @SuppressWarnings("unchecked")
                        List<Map<String, Object>> constructorInjections = (List<Map<String, Object>>) classData.get("constructorInjections");
                        if (constructorInjections == null) {
                            constructorInjections = new ArrayList<>();
                            classData.put("constructorInjections", constructorInjections);
                        }

                        Map<String, Object> injectionData = new HashMap<>();
                        injectionData.put("type", fromFqn);
                        injectionData.put("injectionType", kind.substring(12)); // Remove "constructor:" prefix

                        // Add qualifier if present
                        if (edge.containsKey("qualifier")) {
                            injectionData.put("qualifier", edge.get("qualifier"));
                        }

                        constructorInjections.add(injectionData);
                    }
                } else if (kind != null && kind.startsWith("setter:")) {
                    // Setter/method injection
                    // Extract class FQN from toFqn (which is the class)
                    Map<String, Object> classData = classByFqn.get(toFqn);
                    if (classData != null) {
                        // Store setter injection info in class data
                        @SuppressWarnings("unchecked")
                        List<Map<String, Object>> setterInjections = (List<Map<String, Object>>) classData.get("setterInjections");
                        if (setterInjections == null) {
                            setterInjections = new ArrayList<>();
                            classData.put("setterInjections", setterInjections);
                        }

                        Map<String, Object> injectionData = new HashMap<>();
                        injectionData.put("type", fromFqn);
                        injectionData.put("injectionType", kind.substring(7)); // Remove "setter:" prefix

                        // Add qualifier if present
                        if (edge.containsKey("qualifier")) {
                            injectionData.put("qualifier", edge.get("qualifier"));
                        }

                        setterInjections.add(injectionData);
                    }
                }
            }
        }

        // Build final response
        Map<String, Object> response = new HashMap<>();
        response.put("success", true);
        response.put("classes", new ArrayList<>(classByFqn.values()));
        logger.info("[ANALYSIS_COMPLETE] Analysis completed: {} classes processed, {} nodes, {} edges", classByFqn.size(), nodes.size(), edges.size());

        return response;
    }

    /**
     * Lightweight indexing endpoint - returns grouped class symbols (excludes enums)
     *
     * Request body:
     * {
     *   "classFile": "/path/to/MyClass.class"
     * }
     */
    public Map<String, Object> index(Map<String, Object> request) throws IOException {
        // classFile is required
        if (!request.containsKey("classFile")) {
            throw new IllegalArgumentException("classFile is required");
        }

        String classFilePath = (String) request.get("classFile");

        // Validate class file
        Path classFile = Paths.get(classFilePath);
        if (!Files.exists(classFile) || !classFilePath.endsWith(".class")) {
            throw new IllegalArgumentException("Invalid class file: " + classFilePath);
        }

        logger.info("Indexing class file: {}", classFile);

        // Extract symbols
        String classFqn = null;
        boolean isEntity = false;
        List<Map<String, Object>> symbols = new ArrayList<>();

        try {
            ClassAnalyzer analyzer = new ClassAnalyzer(classFile);
            analyzer.analyze();

            // First pass: find the class node and check if it's an enum
            for (Map<String, Object> node : analyzer.getNodes()) {
                String nodeType = (String) node.get("nodeType");

                if ("enum".equals(nodeType)) {
                    // Skip enums entirely
                    Map<String, Object> response = new HashMap<>();
                    response.put("success", true);
                    response.put("skipped", true);
                    response.put("reason", "enum");
                    return response;
                }

                if ("class".equals(nodeType) || "interface".equals(nodeType)) {
                    classFqn = (String) node.get("fqn");
                    isEntity = node.get("isEntity") != null && (Boolean) node.get("isEntity");
                    break;
                }
            }

            // Second pass: collect all symbols (class + methods)
            for (Map<String, Object> node : analyzer.getNodes()) {
                String nodeType = (String) node.get("nodeType");
                String fqn = (String) node.get("fqn");

                Map<String, Object> symbol = new HashMap<>();
                symbol.put("fqn", fqn);
                symbol.put("nodeType", nodeType);
                symbol.put("line", node.get("lineNumber"));
                symbol.put("isEntity", isEntity); // Use class's isEntity for all symbols
                symbols.add(symbol);
            }
        } catch (Exception e) {
            throw new IOException("Failed to index " + classFile + ": " + e.getMessage(), e);
        }

        // Build grouped response
        Map<String, Object> response = new HashMap<>();
        response.put("success", true);
        response.put("class_fqn", classFqn);
        response.put("is_entity", isEntity);
        response.put("symbols", symbols);

        return response;
    }

    /**
     * Batch indexing endpoint - indexes multiple class files in one request
     *
     * Request body:
     * {
     *   "classFiles": ["/path/to/Class1.class", "/path/to/Class2.class", ...]
     * }
     */
    public Map<String, Object> indexBatch(Map<String, Object> request) throws IOException {
        // classFiles is required
        if (!request.containsKey("classFiles")) {
            throw new IllegalArgumentException("classFiles array is required");
        }

        @SuppressWarnings("unchecked")
        List<String> classFilePaths = (List<String>) request.get("classFiles");

        if (classFilePaths == null || classFilePaths.isEmpty()) {
            throw new IllegalArgumentException("classFiles array cannot be empty");
        }

        logger.info("Batch indexing {} class files", classFilePaths.size());

        List<Map<String, Object>> results = new ArrayList<>();

        // Process each class file
        for (String classFilePath : classFilePaths) {
            Map<String, Object> result = new HashMap<>();

            try {
                // Validate class file
                Path classFile = Paths.get(classFilePath);
                if (!Files.exists(classFile) || !classFilePath.endsWith(".class")) {
                    result.put("success", false);
                    result.put("error", "Invalid class file: " + classFilePath);
                    results.add(result);
                    continue;
                }

                // Extract symbols
                String classFqn = null;
                boolean isEntity = false;
                boolean isEnum = false;
                List<Map<String, Object>> symbols = new ArrayList<>();

                ClassAnalyzer analyzer = new ClassAnalyzer(classFile);
                analyzer.analyze();

                // First pass: find the class node and check if it's an enum
                for (Map<String, Object> node : analyzer.getNodes()) {
                    String nodeType = (String) node.get("nodeType");

                    if ("enum".equals(nodeType)) {
                        // Skip enums entirely
                        isEnum = true;
                        break;
                    }

                    if ("class".equals(nodeType) || "interface".equals(nodeType)) {
                        classFqn = (String) node.get("fqn");
                        isEntity = node.get("isEntity") != null && (Boolean) node.get("isEntity");
                        break;
                    }
                }

                // If it's an enum, mark as skipped and continue to next file
                if (isEnum) {
                    result.put("success", true);
                    result.put("skipped", true);
                    result.put("reason", "enum");
                    results.add(result);
                    continue;
                }

                // Second pass: collect all symbols (class + methods)
                for (Map<String, Object> node : analyzer.getNodes()) {
                    String nodeType = (String) node.get("nodeType");
                    String fqn = (String) node.get("fqn");

                    Map<String, Object> symbol = new HashMap<>();
                    symbol.put("fqn", fqn);
                    symbol.put("nodeType", nodeType);
                    symbol.put("line", node.get("lineNumber"));
                    symbol.put("isEntity", isEntity);
                    symbols.add(symbol);
                }

                // Build result for this file
                result.put("success", true);
                result.put("class_fqn", classFqn);
                result.put("is_entity", isEntity);
                result.put("symbols", symbols);
                results.add(result);

            } catch (Exception e) {
                result.put("success", false);
                result.put("error", "Failed to index " + classFilePath + ": " + e.getMessage());
                results.add(result);
            }
        }

        // Build batch response
        Map<String, Object> response = new HashMap<>();
        response.put("success", true);
        response.put("results", results);

        return response;
    }

    /**
     * Check if a class FQN matches any of the domain filters
     * Returns true if domains is empty OR if fqn starts with at least one domain
     */
    private boolean matchesDomainFilter(String fqn, List<String> domains) {
        if (domains == null || domains.isEmpty()) {
            return true;
        }
        for (String domain : domains) {
            if (fqn.startsWith(domain)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Health check response
     */
    public Map<String, Object> health() {
        Map<String, Object> health = new HashMap<>();
        health.put("status", "ok");
        health.put("service", "ASMAnalysisService (Spring Boot)");
        health.put("version", "1.0.0");
        health.put("timestamp", new Date());
        return health;
    }
}