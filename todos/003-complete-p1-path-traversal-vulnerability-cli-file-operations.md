---
status: complete
priority: p1
issue_id: "003"
tags:
  - code-review
  - security
  - path-traversal
dependencies: []
---

# Path Traversal Vulnerability in CLI File Operations

## Problem Statement

File paths from untrusted sources (database) are used to open files without validation. An attacker who can modify the database could read arbitrary files from the filesystem.

**Location:** `ariadne_cli/main.py:487-492`

```python
# In _cmd_summarize()
file_path = symbol.get("file_path")
if not file_path or not Path(file_path).exists():
    continue
with open(file_path) as f:
    source_code = f.read()
```

## Why It Matters

1. **Arbitrary File Read**: If database is compromised, attacker can read any file the process has access to
2. **Credential Exposure**: Could read `.env`, `.aws/credentials`, SSH keys, etc.
3. **Source Code Disclosure**: Could read source code outside the project directory
4. **Supply Chain Attack**: Combined with other vulnerabilities, could lead to full system compromise

## Findings

### From Security Sentinel Review:

> **Severity:** HIGH
> **CVE Class:** CWE-22 (Improper Limitation of a Pathname to a Restricted Directory)
>
> File paths from untrusted sources (database) are used to open files without validation. If database is compromised or contains malicious data, attacker can read arbitrary files.

**Attack Scenario:**
```sql
-- Attacker modifies database
UPDATE symbols SET file_path = '/etc/passwd' WHERE fqn = 'com.example.Foo';
UPDATE symbols SET file_path = '../../../.env' WHERE fqn = 'com.example.Bar';

-- CLI reads arbitrary files
ariadne summarize --project /tmp/project --db ariadne.db
# Reads /etc/passwd and .env file!
```

## Proposed Solutions

### Solution 1: Path Validation with Project Root Containment (Recommended)

**Approach:** Resolve paths and verify they are within the project root directory

**Pros:**
- Prevents all path traversal attacks
- Standard security pattern
- Clear error messages

**Cons:**
- Requires project root parameter in all commands
- May break symlinks to files outside project

**Effort:** Low
**Risk:** Low

**Implementation:**
```python
# In _cmd_summarize()
project_root = Path(args.project).resolve()

for symbol in symbols:
    file_path = symbol.get("file_path")
    if not file_path:
        continue

    # Resolve and validate path is within project root
    resolved_path = Path(file_path).resolve()

    try:
        resolved_path.relative_to(project_root)
    except ValueError:
        logger.warning(f"Path outside project root: {file_path}")
        continue

    if not resolved_path.exists():
        continue

    with open(resolved_path) as f:
        source_code = f.read()
```

**Reusable Helper:**
```python
def validate_project_path(file_path: str, project_root: Path) -> Path | None:
    """Validate that file_path is within project_root.

    Returns resolved Path if valid, None otherwise.
    """
    resolved_path = Path(file_path).resolve()

    try:
        resolved_path.relative_to(project_root)
    except ValueError:
        logger.warning(f"Path outside project root: {file_path}")
        return None

    if not resolved_path.exists():
        logger.warning(f"Path does not exist: {file_path}")
        return None

    return resolved_path
```

### Solution 2: Database-Level Path Validation

**Approach:** Validate paths when inserting into database

**Pros:**
- Centralized validation
- Prevents bad data at source

**Cons:**
- Doesn't protect against direct database modification
- Requires migration
- Less flexible

**Effort:** Medium
**Risk:** Low

**Implementation:**
```python
# In SQLiteStore.insert_symbols()
def insert_symbols(self, symbols: list[SymbolData]) -> int:
    for symbol in symbols:
        if symbol.file_path:
            # Validate path exists and is accessible
            if not Path(symbol.file_path).exists():
                logger.warning(f"Skipping symbol with non-existent path: {symbol.file_path}")
                continue
```

### Solution 3: Chroot/Sandbox (Overkill for this use case)

**Approach:** Use OS-level sandboxing to restrict file access

**Pros:**
- Strongest security boundary

**Cons:**
- Complex implementation
- Platform-specific
- Overkill for CLI tool

**Effort:** High
**Risk:** Medium

## Recommended Action

**Use Solution 1 (Path Validation)**

Implement the `validate_project_path()` helper and use it in all CLI commands that read files from database-provided paths.

## Technical Details

### Files to Modify:
1. `ariadne_cli/main.py` - Add path validation to all file reading operations
2. `ariadne_core/storage/sqlite_store.py` - Consider adding validation at insert time

### Affected CLI Commands:
- `_cmd_summarize()` - lines 448-531 (PRIMARY)
- Any other commands that read `file_path` from database

### Helper Function Location:
```python
# ariadne_cli/main.py
def validate_project_path(file_path: str, project_root: Path) -> Path | None:
    """Validate that file_path is within project_root."""
    # ... implementation ...
```

### Test Cases Needed:
- [ ] Normal file within project - passes
- [ ] Absolute path outside project - rejected
- [ ] Relative path with `../` - rejected
- [ ] Symlink within project - passes (optional)
- [ ] Symlink outside project - rejected (optional)
- [ ] Non-existent path - rejected

## Acceptance Criteria

- [ ] `validate_project_path()` helper function implemented
- [ ] All file reads in CLI use validation helper
- [ ] Tests for path traversal attempts
- [ ] Tests for valid paths
- [ ] Error messages logged for rejected paths
- [ ] Documentation updated with security notes

## Work Log

| Date | Action | Result |
|------|--------|--------|
| 2026-02-01 | Code review completed | Path traversal vulnerability identified |
| 2026-02-01 | Added path validation | validate_project_path() helper prevents path traversal attacks in CLI, updated _cmd_summarize to use context managers |

## Resources

- **Files**: `ariadne_cli/main.py`
- **CWE-22**: https://cwe.mitre.org/data/definitions/22.html
- **OWASP Path Traversal**: https://owasp.org/www-community/attacks/Path_Traversal
- **Python Pathlib Security**: https://docs.python.org/3/library/pathlib.html
- **Related**: Todo #001 (API Keys) - also security related
