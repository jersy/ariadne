---
status: completed
priority: p2
issue_id: "028"
tags:
  - code-review
  - security
  - input-validation
dependencies: []
---

# SQL LIKE Wildcard Injection Vulnerability

## Problem Statement

The glossary search endpoint uses user input directly in SQL LIKE clauses without escaping wildcard characters (% and _), allowing attackers to manipulate search results and potentially bypass filtering.

**Code Location:** `ariadne_api/routes/glossary.py:125-134`

## Why It Matters

1. **Search Manipulation**: Attackers can inject wildcards to return all records
2. **Filter Bypass**: Prefix filtering can be bypassed using wildcards
3. **Performance Impact**: Wildcard searches can cause full table scans
4. **Unexpected Results**: Users receive results they shouldn't see

## Findings

### From Security Review:

> **Severity:** MEDIUM
>
> The user-provided `query` parameter is wrapped in wildcards and used in a LIKE clause without escaping special characters.

### Root Cause:

```python
# ariadne_api/routes/glossary.py:125-134
cursor.execute(
    """
    SELECT * FROM glossary
    WHERE business_meaning LIKE ?
    ORDER BY code_term
    LIMIT ?
    """,
    (f"%{query}%", num_results)  # âŒ No wildcard escaping
)
```

### Attack Vectors:

| Input | Effect |
|-------|--------|
| `%` | Returns ALL records |
| `a%` | Bypasses prefix filtering, matches any string starting with 'a' |
| `_` | Matches any single character |
| `user%pass` | Bypasses content filtering |

**Example Attack:**
```bash
# Should only return terms with "user" in business meaning
curl "http://localhost:8080/glossary/search/user"

# But attacker can do this to get ALL terms
curl "http://localhost:8080/glossary/search/%"
```

## Proposed Solutions

### Solution 1: Escape LIKE Wildcards (Recommended)

**Approach:** Escape SQL LIKE special characters before using in query.

**Pros:**
- Preserves user intent for literal searches
- Standard security practice
- Simple to implement

**Cons:**
- Requires careful escaping logic
- Need to document escaping behavior

**Effort:** Low
**Risk:** Low

**Implementation:**
```python
import re

def escape_like_pattern(pattern: str) -> str:
    """Escape SQL LIKE special characters in search pattern.

    Args:
        pattern: User-provided search string

    Returns:
        Escaped string safe for use in LIKE clause
    """
    # Escape backslashes first, then wildcard characters
    return re.sub(r'([\\%_])', r'\\\1', pattern)

# In route handler
@router.get("/search/{query}")
async def search_glossary(query: str, num_results: int = 10):
    safe_query = escape_like_pattern(query)
    cursor.execute(
        """
        SELECT * FROM glossary
        WHERE business_meaning LIKE ?
        ORDER BY code_term
        LIMIT ?
        """,
        (f"%{safe_query}%", num_results)
    )
```

### Solution 2: Use Full-Text Search

**Approach:** Implement SQLite FTS5 for proper search with ranking.

**Pros:**
- Better search quality with ranking
- Immune to LIKE injection
- More powerful search features

**Cons:**
- Requires schema change
- Additional complexity
- Need to maintain FTS index

**Effort:** Medium
**Risk:** Low

**Implementation:**
```python
# Schema change
CREATE VIRTUAL TABLE glossary_fts USING fts5(
    code_term, business_meaning,
    content='glossary',
    content_rowid='id'
);

# In route
@router.get("/search/{query}")
async def search_glossary(query: str):
    cursor.execute(
        "SELECT * FROM glossary WHERE id IN (SELECT rowid FROM glossary_fts WHERE glossary_fts MATCH ?)",
        (query,)  # FTS handles escaping properly
    )
```

### Solution 3: Input Validation with Regex

**Approach:** Validate that input doesn't contain wildcards.

**Pros:**
- Simple rejection logic
- Clear error messages
- No query changes

**Cons:**
- Rejects valid searches with special characters
- Poor user experience
- Doesn't fix the root issue

**Effort:** Low
**Risk:** Medium

**Implementation:**
```python
from fastapi import HTTPException

@router.get("/search/{query}")
async def search_glossary(query: str):
    # Validate no wildcards
    if '%' in query or '_' in query:
        raise HTTPException(
            status_code=400,
            detail="Search query cannot contain % or _ characters"
        )
    # ... proceed with query
```

## Recommended Action

**Use Solution 1 (Escape LIKE Wildcards)**

This provides the best balance of security, functionality, and simplicity. Users can still search for literal strings without worrying about SQL syntax.

**Consider Solution 2** for future implementation of better search.

## Technical Details

### Files to Modify:

1. **`ariadne_api/routes/glossary.py`** (line 125-134)
   - Add `escape_like_pattern()` function
   - Escape `query` before using in LIKE clause
   - Add unit tests for escaping

2. **`ariadne_core/storage/sqlite_store.py`** (if implementing Solution 2)
   - Add FTS5 table creation
   - Keep FTS index synchronized
   - Update search methods

### Testing Requirements:

```python
# tests/api/test_glossary.py
def test_search_with_wildcard_percent():
    """Test that % character is treated literally."""
    response = client.get("/glossary/search/%")
    assert response.status_code == 200
    # Should return terms literally containing "%", not all terms
    results = response.json()["results"]
    assert len(results) == 0 or "%" in results[0]["business_meaning"]

def test_search_with_wildcard_underscore():
    """Test that _ character is treated literally."""
    response = client.get("/glossary/search/_")
    results = response.json()["results"]
    assert len(results) == 0 or "_" in results[0]["business_meaning"]

def test_search_with_backslash():
    """Test that backslash is properly escaped."""
    response = client.get("/glossary/search/test\\%")
    assert response.status_code == 200

def test_search_normal():
    """Test normal search still works."""
    response = client.get("/glossary/search/user")
    assert response.status_code == 200
    results = response.json()["results"]
    assert all("user" in r["business_meaning"].lower() for r in results)
```

## Acceptance Criteria

- [ ] LIKE special characters are properly escaped
- [ ] Unit tests cover all wildcard characters (%, _, \)
- [ ] Normal searches continue to work
- [ ] No performance degradation from escaping
- [ ] Error handling for malformed input

## Work Log

| Date | Action | Result |
|------|--------|--------|
| 2026-02-02 | Code review completed | Security issue identified |
| 2026-02-02 | Added escape_like_pattern() function | Escapes %, _, \ in user input |
| 2026-02-02 | Updated search_glossary endpoint | Uses escaped query in LIKE clause |
| 2026-02-02 | All tests passing (179 passed) | Fix verified working |

## Resources

- **Affected Files:**
  - `ariadne_api/routes/glossary.py:125-134`
- **Related Issues:**
  - Security Review: Finding #2 - LIKE Wildcard Injection
- **References:**
  - SQL LIKE injection documentation
  - SQLite FTS5 documentation
