# Compound Engineering Plugin 核心工作流详解

> **文档版本**: 基于 Compound Engineering Plugin v2.28.0
> **生成日期**: 2026-01-31

---

## 1. 完整工作流生命周期

Compound Engineering Plugin 定义了一个完整的、端到端的 AI 驱动开发工作流,从需求探索到知识复合,每个阶段都有明确的命令支持。

### 1.1 工作流全景图

```
┌─────────────────────────────────────────────────────────────┐
│ 阶段 1: BRAINSTORM (需求探索与设计)                            │
│ ────────────────────────────────────────────────────────────│
│ 触发: /workflows:brainstorm                                  │
│ 场景: 任何新功能、重大修改、不明确需求                           │
│ 输出: docs/brainstorms/YYYY-MM-DD-<topic>-brainstorm.md    │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 2: PLAN (实现计划编写)                                    │
│ ────────────────────────────────────────────────────────────│
│ 触发: /workflows:plan                                        │
│ 场景: 有明确需求或批准的设计文档                                 │
│ 输出: docs/plans/YYYY-MM-DD-<topic>-plan.md                │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 3: WORK (计划执行)                                        │
│ ────────────────────────────────────────────────────────────│
│ 触发: /workflows:work                                        │
│ 场景: 有批准的实现计划                                          │
│ 输出: 代码变更 + 增量提交 + Pull Request                        │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 4: REVIEW (代码审查)                                      │
│ ────────────────────────────────────────────────────────────│
│ 触发: /workflows:review                                      │
│ 场景: PR 创建后、代码完成后                                     │
│ 输出: todos/*.md (待办事项文件) + 审查报告                       │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│ 阶段 5: COMPOUND (知识复合)                                    │
│ ────────────────────────────────────────────────────────────│
│ 触发: /workflows:compound                                    │
│ 场景: 问题解决后、需要文档化学习                                 │
│ 输出: docs/solutions/<category>/<topic>.md                  │
└─────────────────────────────────────────────────────────────┘
```

**贯穿始终的技能与代理**:
- 🔍 **Research Agents** - 文档研究、最佳实践查找
- 📝 **Review Agents** - 代码审查、安全扫描、性能分析
- 🛠️ **Workflow Agents** - 测试运行、CI 调试、PR 解决
- 📚 **Skills** - TDD、API 设计、技术写作

---

## 2. 阶段 1: Brainstorm (需求探索与设计)

### 2.1 命令签名

```bash
/workflows:brainstorm [feature idea or problem to explore]
```

### 2.2 触发条件

**必须使用**的场景:
- ✅ 探索新功能或重大改进
- ✅ 需求不明确,需要细化
- ✅ 多种方案可选,需要评估
- ✅ 复杂问题需要结构化思考
- ✅ 跨组件的架构变更

**跳过**的场景:
- ❌ 需求已经非常明确
- ❌ 简单的 bug 修复
- ❌ 文档更新
- ❌ 直接参考已有设计

### 2.3 执行流程

```
Phase 0: 评估需求清晰度
   ├─ 检查描述是否包含明确的验收标准
   ├─ 是否有参考模式或示例
   ├─ 是否描述了精确的预期行为
   └─ 如果清晰 → 建议跳到 /workflows:plan

Phase 1: 理解想法
   ├─ 1.1 仓库研究 (轻量级)
   │   └─ Task repo-research-analyst("理解相关模式")
   │
   └─ 1.2 协作对话
       ├─ 使用 AskUserQuestion 工具逐个提问
       ├─ 优先多选题(有明确选项时)
       ├─ 从广泛(目的、用户)到具体(约束、边缘案例)
       ├─ 明确验证假设
       └─ 询问成功标准

Phase 2: 探索方案
   ├─ 提出 2-3 种具体方案
   ├─ 每方案包含:
   │   ├─ 简要描述(2-3 句)
   │   ├─ 优缺点分析
   │   └─ 适用场景
   ├─ 推荐一个方案并解释原因
   └─ 应用 YAGNI 原则(优先简单方案)

Phase 3: 捕获设计
   ├─ 写入 docs/brainstorms/YYYY-MM-DD-<topic>-brainstorm.md
   ├─ 确保目录存在
   └─ 使用结构化模板(见下文)

Phase 4: 交接
   └─ 使用 AskUserQuestion 提示下一步:
       1. 继续规划 - 运行 /workflows:plan
       2. 进一步细化 - 继续探索
       3. 暂时完成 - 稍后返回
```

### 2.4 设计文档模板

```markdown
---
title: [功能名称]
date: YYYY-MM-DD
status: brainstorm
---

# [功能名称] - 设计探索

## 我们要构建什么

[单句描述目标]

## 为什么选择这个方案

[2-3 段解释选择的方法和原因]

## 关键决策

| 决策点 | 选择 | 原因 |
|--------|------|------|
| [决策 1] | [选择] | [为什么] |
| [决策 2] | [选择] | [为什么] |

## 未解决的问题

- [ ] [问题 1]
- [ ] [问题 2]

## 探索的替代方案

### 方案 A (选择)
- **描述**: [方案说明]
- **优点**: [优势]
- **缺点**: [劣势]
- **选择原因**: [为什么]

### 方案 B (未选择)
- **描述**: [方案说明]
- **优点**: [优势]
- **缺点**: [劣势]
- **未选择原因**: [为什么]

## 下一步

1. 运行 `/workflows:plan` 创建实现计划
2. 解决未解决的问题
3. [其他步骤]
```

### 2.5 最佳实践

**✅ DO**:
- 一次只问一个问题(避免信息过载)
- 提供具体的多选项(非开放式问题)
- 分段呈现设计(200-300 词/段)
- 探索替代方案(展示思考深度)
- 应用 YAGNI 原则(优先简单解决方案)
- 明确验证假设(不要猜测)

**❌ DON'T**:
- 一次问多个问题
- 直接跳到实现细节(那是计划阶段的事)
- 整篇文档一次性输出
- 假设用户需求(必须确认)
- 过早优化
- 编写代码(仅探索和文档化)

### 2.6 代理调度

```
主命令: /workflows:brainstorm
    ↓
派遣研究代理
    └─ repo-research-analyst
        ├─ 查找相似功能
        ├─ 识别已有模式
        ├─ 检查 CLAUDE.md 指南
        └─ 返回研究结果
    ↓
协作对话 (主代理)
    ├─ 逐个提问细化需求
    ├─ 探索多种方案
    └─ 推荐最佳方案
    ↓
文档化设计
```

---

## 3. 阶段 2: Plan (实现计划编写)

### 3.1 命令签名

```bash
/workflows:plan [feature description, bug report, or improvement idea]
```

### 3.2 触发条件

**适用场景**:
- ✅ 有明确的功能描述
- ✅ 有批准的设计文档(来自 brainstorm)
- ✅ Bug 报告需要系统化修复
- ✅ 改进想法需要结构化实现
- ✅ 任何需要详细计划的工作

### 3.3 执行流程

```
Step 0: 想法细化
   ├─ 检查 docs/brainstorms/ 是否有相关设计
   │   ├─ 相关标准: 主题匹配 + 14 天内创建
   │   ├─ 如果找到 → 读取并提取关键决策
   │   └─ 如果未找到 → 运行细化对话
   │
   └─ 收集研究决策信号
       ├─ 用户熟悉度(是否知道代码库模式)
       ├─ 用户意图(速度 vs 彻底性)
       ├─ 主题风险(安全、支付、外部 API)
       └─ 不确定性级别(方案清晰 vs 开放性)

Step 1: 本地研究 (始终运行 - 并行)
   ├─ Task repo-research-analyst(feature_description)
   │   ├─ 查找现有模式
   │   ├─ 检查 CLAUDE.md 指南
   │   ├─ 评估技术熟悉度
   │   └─ 识别模式一致性
   │
   └─ Task learnings-researcher(feature_description)
       ├─ 搜索 docs/solutions/
       ├─ 查找相关的已记录解决方案
       └─ 提取经验教训

Step 1.5: 研究决策
   基于 Step 0 信号和 Step 1 发现做决策:

   IF 高风险主题 (安全、支付、外部 API)
       → 始终进行外部研究

   ELSE IF 强本地上下文 (良好模式、CLAUDE.md 指南、用户知情)
       → 跳过外部研究

   ELSE IF 不确定或不熟悉
       → 进行外部研究

   公布决策并继续

Step 1.5b: 外部研究 (条件性)
   仅当 Step 1.5 指示需要时运行:

   ├─ Task best-practices-researcher(feature_description)
   └─ Task framework-docs-researcher(feature_description)

Step 1.6: 整合研究
   ├─ 记录相关文件路径(repo 研究)
   ├─ 包含相关机构学习(docs/solutions/)
   ├─ 记录外部文档 URL(如果有)
   ├─ 列出相关 issues 或 PRs
   └─ 捕获 CLAUDE.md 约定

Step 2: Issue 规划与结构
   ├─ 起草清晰、可搜索的标题
   │   格式: feat: / fix: / refactor: + 描述
   │   示例: feat: Add user authentication
   │
   ├─ 确定 issue 类型
   │   类型: enhancement, bug, refactor
   │
   ├─ 转换为文件名
   │   规则: YYYY-MM-DD-<type>-<name>-plan.md
   │   示例: 2026-01-31-feat-user-auth-plan.md
   │
   ├─ 利益相关者分析
   │   ├─ 识别受影响的人(用户、开发者、运维)
   │   └─ 评估实现复杂度和所需专业知识
   │
   └─ 内容规划
       ├─ 选择适当的详细程度
       ├─ 列出所有必要章节
       └─ 收集支持材料

Step 3: SpecFlow 分析
   └─ Task spec-flow-analyzer(feature_description, research_findings)
       ├─ 审查 SpecFlow 分析结果
       ├─ 识别缺口或边缘案例
       └─ 基于发现更新验收标准

Step 4: 选择实现详细程度
   三种模板可选:

   📄 MINIMAL (快速 Issue)
      适用于: 简单 bugs、小改进、清晰功能
      包含: 问题描述 + 验收标准 + 基本上下文

   📋 MORE (标准 Issue)
      适用于: 大多数功能、复杂 bugs、团队协作
      包含: MINIMAL + 详细背景 + 技术考虑 + 依赖

   📚 A LOT (全面 Issue)
      适用于: 主要功能、架构变更、复杂集成
      包含: MORE + 实现阶段 + 替代方案 + 风险缓解

Step 5: Issue 创建与格式化
   ├─ 使用清晰的标题层次(##, ###)
   ├─ 代码示例使用语法高亮
   ├─ UI 相关添加截图/mockups
   ├─ 可追踪项使用任务列表(- [ ])
   ├─ 使用 <details> 标签折叠长日志
   └─ 应用适当的 emoji 进行视觉扫描

Step 6: 最终审查与提交
   ├─ 标题可搜索且描述性强
   ├─ 所有模板章节完整
   ├─ 链接和引用有效
   ├─ 验收标准可衡量
   └─ 伪代码示例中添加文件名
```

### 3.4 计划文档结构

#### 📄 MINIMAL 模板

```markdown
---
title: [Issue 标题]
type: feat|fix|refactor
date: YYYY-MM-DD
---

# [Issue 标题]

[简要问题/功能描述]

## 验收标准

- [ ] 核心需求 1
- [ ] 核心需求 2

## 上下文

[任何关键信息]

## MVP

### test.rb

```ruby
class Test
  def initialize
    @name = "test"
  end
end
```

## 参考

- 相关 issue: #[issue_number]
- 文档: [relevant_docs_url]
```

#### 📋 MORE 模板

```markdown
---
title: [Issue 标题]
type: feat|fix|refactor
date: YYYY-MM-DD
---

# [Issue 标题]

## 概览

[全面描述]

## 问题陈述 / 动机

[为什么重要]

## 建议解决方案

[高层方法]

## 技术考虑

- 架构影响
- 性能影响
- 安全考虑

## 验收标准

- [ ] 详细需求 1
- [ ] 详细需求 2
- [ ] 测试需求

## 成功指标

[如何衡量成功]

## 依赖与风险

[可能阻塞或复杂化的因素]

## 参考与研究

- 类似实现: [file_path:line_number]
- 最佳实践: [documentation_url]
- 相关 PRs: #[pr_number]
```

#### 📚 A LOT 模板

在 MORE 基础上增加:

```markdown
## 技术方法

### 架构

[详细技术设计]

### 实现阶段

#### 阶段 1: [基础]
- 任务和交付物
- 成功标准
- 预估工作量

#### 阶段 2: [核心实现]
- 任务和交付物
- 成功标准
- 预估工作量

## 考虑的替代方案

[评估的其他解决方案及为何拒绝]

## 风险分析与缓解

[全面的风险评估]

## 资源需求

[团队、时间、基础设施需求]

## 未来考虑

[可扩展性和长期愿景]
```

### 3.5 生成后选项

计划创建后,使用 **AskUserQuestion** 工具提供选项:

```
计划已就绪: docs/plans/YYYY-MM-DD-<type>-<name>-plan.md

接下来您想做什么?

1. 在编辑器中打开计划 - 审查计划文件
2. 运行 /deepen-plan - 通过并行研究代理增强每个章节
3. 运行 /plan_review - 从审查者获得反馈
4. 启动 /workflows:work - 开始本地实现
5. 在远程启动 /workflows:work - 在 Claude Code web 上实现
6. 创建 Issue - 在项目跟踪器中创建 issue
7. 简化 - 减少详细程度
```

### 3.6 代理调度机制

```
主命令: /workflows:plan
    ↓
并行研究代理 (始终运行)
    ├─ repo-research-analyst
    │   ├─ 分析现有模式
    │   ├─ 检查 CLAUDE.md
    │   └─ 返回本地上下文
    │
    └─ learnings-researcher
        ├─ 搜索 docs/solutions/
        └─ 返回相关学习
    ↓
研究决策逻辑
    ├─ 评估风险、熟悉度、不确定性
    └─ 决定是否需要外部研究
    ↓
条件性外部研究 (如需要)
    ├─ best-practices-researcher
    │   └─ 查找行业最佳实践
    │
    └─ framework-docs-researcher
        └─ 搜索框架文档
    ↓
SpecFlow 分析
    └─ spec-flow-analyzer
        ├─ 验证规范
        └─ 识别缺口
    ↓
计划生成 (主代理)
    ├─ 整合所有研究
    ├─ 选择模板详细程度
    └─ 创建计划文档
```

---

## 4. 阶段 3: Work (计划执行)

### 4.1 命令签名

```bash
/workflows:work [plan file, specification, or todo file path]
```

### 4.2 核心理念

**快速启动,快速执行,完整交付**

- 在开始时获得澄清,然后执行
- 边测试边开发(不是最后测试)
- 质量内建(遵循现有模式)
- 交付完整功能(不是 80% 完成)

### 4.3 执行流程

```
Phase 1: 快速启动

1. 读取计划并澄清
   ├─ 完整读取工作文档
   ├─ 审查计划中提供的任何引用或链接
   ├─ 如有不清楚或模糊之处,现在提问
   ├─ 获得用户批准继续
   └─ 不要跳过此步骤

2. 设置环境
   检查当前分支:

   IF 在功能分支上 (非默认分支)
       → 询问: "继续在当前分支工作,还是创建新分支?"

   ELSE IF 在默认分支上
       → 提供选项:
           A. 创建新分支
              git checkout -b feature-branch-name

           B. 使用 worktree (推荐用于并行开发)
              skill: git-worktree

           C. 继续在默认分支上
              需要明确用户确认
              仅在用户明确说"是的,提交到默认分支"后继续

3. 创建待办事项列表
   ├─ 使用 TodoWrite 将计划分解为可操作任务
   ├─ 包含任务间依赖关系
   ├─ 基于优先级排序
   ├─ 包含测试和质量检查任务
   └─ 保持任务具体且可完成

Phase 2: 执行

1. 任务执行循环

   WHILE (存在待完成任务):
       ├─ 在 TodoWrite 中标记任务为 in_progress
       ├─ 读取计划中引用的任何文件
       ├─ 在代码库中查找类似模式
       ├─ 遵循现有约定实现
       ├─ 为新功能编写测试
       ├─ 更改后运行测试
       ├─ 在 TodoWrite 中标记任务为 completed
       ├─ 在计划文件中勾选对应复选框 ([ ] → [x])
       └─ 评估是否增量提交

2. 增量提交

   何时提交:
   ✅ 逻辑单元完成(模型、服务、组件)
   ✅ 测试通过 + 有意义的进展
   ✅ 即将切换上下文(后端 → 前端)
   ✅ 即将尝试风险/不确定的更改

   何时不提交:
   ❌ 只完成大单元的小部分
   ❌ 测试失败
   ❌ 纯脚手架无行为
   ❌ 需要"WIP"提交信息

   提交工作流:
   # 1. 验证测试通过
   [项目的测试命令]  # bin/rails test, npm test, pytest, 等

   # 2. 仅暂存此逻辑单元相关的文件 (不是 git add .)
   git add <此逻辑单元相关的文件>

   # 3. 使用常规消息提交
   git commit -m "feat(scope): 此单元的描述"

3. 遵循现有模式
   ├─ 计划应该引用类似代码 - 首先阅读这些文件
   ├─ 完全匹配命名约定
   ├─ 尽可能重用现有组件
   ├─ 遵循项目编码标准(参见 CLAUDE.md)
   └─ 有疑问时,grep 查找类似实现

4. 持续测试
   ├─ 每次重要更改后运行相关测试
   ├─ 不要等到最后才测试
   ├─ 立即修复失败
   └─ 为新功能添加新测试

5. Figma 设计同步 (如适用)
   对于有 Figma 设计的 UI 工作:
   ├─ 按照设计规范实现组件
   ├─ 迭代使用 figma-design-sync 代理进行比较
   ├─ 修复识别的视觉差异
   └─ 重复直到实现与设计匹配

6. 跟踪进度
   ├─ 完成任务时保持 TodoWrite 更新
   ├─ 记录任何阻碍或意外发现
   ├─ 如范围扩展则创建新任务
   └─ 告知用户主要里程碑

Phase 3: 质量检查

1. 运行核心质量检查
   提交前始终运行:

   # 运行完整测试套件
   [项目的测试命令]

   # 运行 linting
   # 推送到 origin 前使用 linting-agent

2. 考虑审查代理 (可选)
   用于复杂、风险高或大型更改:

   ├─ code-simplicity-reviewer: 检查不必要的复杂性
   ├─ kieran-rails-reviewer: 验证 Rails 约定
   ├─ performance-oracle: 检查性能问题
   ├─ security-sentinel: 扫描安全漏洞
   └─ cora-test-reviewer: 审查测试质量

   并行运行:
   Task(code-simplicity-reviewer): "审查更改的简洁性"
   Task(kieran-rails-reviewer): "检查 Rails 约定"

3. 最终验证
   ├─ 所有 TodoWrite 任务标记为已完成
   ├─ 所有测试通过
   ├─ Linting 通过
   ├─ 代码遵循现有模式
   ├─ Figma 设计匹配(如适用)
   └─ 无控制台错误或警告

Phase 4: 交付

1. 创建提交
   git add .
   git status  # 审查将要提交的内容
   git diff --staged  # 检查更改

   git commit -m "$(cat <<'EOF'
   feat(scope): 描述做了什么和为什么

   简要解释(如需要)。

   🤖 Generated with [Claude Code](https://claude.com/claude-code)

   Co-Authored-By: Claude <noreply@anthropic.com>
   EOF
   )"

2. 为 UI 更改捕获和上传截图 (UI 工作必需)

   对于任何设计更改、新视图或 UI 修改:

   Step 1: 启动开发服务器
   bin/dev  # 在后台运行

   Step 2: 使用 agent-browser CLI 捕获截图
   agent-browser open http://localhost:3000/[route]
   agent-browser snapshot -i
   agent-browser screenshot output.png

   Step 3: 使用 imgup skill 上传
   skill: imgup
   imgup -h pixhost screenshot.png

   捕获内容:
   - 新屏幕: 新 UI 的截图
   - 修改屏幕: 之前和之后的截图
   - 设计实现: 显示 Figma 设计匹配的截图

3. 创建 Pull Request
   git push -u origin feature-branch-name

   gh pr create --title "Feature: [描述]" --body "$(cat <<'EOF'
   ## 摘要
   - 构建了什么
   - 为什么需要
   - 做出的关键决策

   ## 测试
   - 添加/修改的测试
   - 执行的手动测试

   ## 前后截图
   | 之前 | 之后 |
   |------|------|
   | ![before](URL) | ![after](URL) |

   ## Figma 设计
   [如适用的链接]

   ---

   [![Compound Engineered](https://img.shields.io/badge/Compound-Engineered-6366f1)](https://github.com/EveryInc/compound-engineering-plugin) 🤖 Generated with [Claude Code](https://claude.com/claude-code)
   EOF
   )"

4. 通知用户
   ├─ 总结完成的内容
   ├─ PR 链接
   ├─ 记录任何需要跟进的工作
   └─ 如适用建议下一步
```

### 4.4 质量检查清单

创建 PR 前验证:

- [ ] 所有澄清问题已提问并回答
- [ ] 所有 TodoWrite 任务标记为已完成
- [ ] 测试通过(运行项目的测试命令)
- [ ] Linting 通过(使用 linting-agent)
- [ ] 代码遵循现有模式
- [ ] Figma 设计匹配实现(如适用)
- [ ] 前后截图已捕获并上传(UI 更改)
- [ ] 提交消息遵循常规格式
- [ ] PR 描述包含摘要、测试说明和截图
- [ ] PR 描述包含 Compound Engineered 徽章

### 4.5 何时使用审查代理

**默认不使用**。仅在以下情况使用审查代理:

- 影响多个文件(10+)的大型重构
- 安全敏感的更改(认证、权限、数据访问)
- 性能关键的代码路径
- 复杂的算法或业务逻辑
- 用户明确要求彻底审查

对于大多数功能: 测试 + linting + 遵循模式已足够。

### 4.6 常见陷阱

| 陷阱 | 后果 | 避免方法 |
|------|------|---------|
| 分析瘫痪 | 浪费时间 | 不要过度思考,阅读计划并执行 |
| 跳过澄清问题 | 构建错误的东西 | 现在提问,而不是构建后 |
| 忽略计划引用 | 重新发明轮子 | 计划有链接是有原因的 |
| 最后才测试 | 后期遭受痛苦 | 持续测试或后期痛苦 |
| 忘记 TodoWrite | 失去进度跟踪 | 跟踪进度或失去完成的内容 |
| 80% 完成综合症 | 功能未交付 | 完成功能,不要过早转移 |
| 过度审查简单更改 | 浪费时间 | 为复杂工作保留审查代理 |

---

## 5. 阶段 4: Review (代码审查)

### 5.1 命令签名

```bash
/workflows:review [PR number, GitHub URL, branch name, or latest]
```

### 5.2 核心理念

**穷尽式代码审查,使用多代理分析、超深度思考和 Git worktrees**

- 27 个专业化审查代理
- 并行执行最大化效率
- 基于 worktree 的深度本地检查
- 结构化待办事项管理(todos/*.md)
- 优先级驱动的发现分类(P1/P2/P3)

### 5.3 执行流程

```
Step 1: 确定审查目标并设置

立即行动:
├─ 确定审查类型: PR 号、GitHub URL、文件路径或空(当前分支)
├─ 检查当前 git 分支
├─ 如果已在目标分支上 → 在当前分支继续分析
├─ 如果在不同分支上 → 提供使用 worktree: "使用 git-worktree skill 进行隔离"
├─ 使用 gh pr view --json 获取 PR 元数据
├─ 设置语言特定的分析工具
├─ 准备安全扫描环境
└─ 确保在审查的分支上,然后继续

Step 2: 并行代理审查 PR

同时运行所有或大部分代理:

核心审查代理 (始终运行):
1. Task kieran-rails-reviewer(PR 内容)
2. Task dhh-rails-reviewer(PR 标题)
3. Task git-history-analyzer(PR 内容)
4. Task dependency-detective(PR 内容)
5. Task pattern-recognition-specialist(PR 内容)
6. Task architecture-strategist(PR 内容)
7. Task code-philosopher(PR 内容)
8. Task security-sentinel(PR 内容)
9. Task performance-oracle(PR 内容)
10. Task devops-harmony-analyst(PR 内容)
11. Task data-integrity-guardian(PR 内容)
12. Task agent-native-reviewer(PR 内容)

条件性代理 (基于 PR 内容):
IF PR 包含数据库迁移 (db/migrate/*.rb)
   OR PR 修改存储 ID、枚举或映射的列
   OR PR 包含数据回填脚本
   OR PR 标题/正文提及: migration, backfill, data transformation
   THEN:
       13. Task data-migration-expert(PR 内容)
           验证硬编码映射、检查孤立关联、验证双写模式

       14. Task deployment-verification-agent(PR 内容)
           创建带 SQL 验证查询的 Go/No-Go 部署检查清单

IF PR 使用 Turbo
   THEN:
       15. Task rails-turbo-expert(PR 内容)

Step 3: 超深度思考阶段

Phase 3: 利益相关者视角分析

从每个利益相关者角度思考:

├─ 开发者视角
│   ├─ 理解和修改有多容易?
│   ├─ API 直观吗?
│   ├─ 调试简单吗?
│   └─ 能轻松测试吗?
│
├─ 运维视角
│   ├─ 如何安全部署?
│   ├─ 有哪些指标和日志可用?
│   ├─ 如何排查问题?
│   └─ 资源需求是什么?
│
├─ 最终用户视角
│   ├─ 功能直观吗?
│   ├─ 错误消息有帮助吗?
│   ├─ 性能可接受吗?
│   └─ 解决了我的问题吗?
│
├─ 安全团队视角
│   ├─ 攻击面是什么?
│   ├─ 有合规要求吗?
│   ├─ 数据如何保护?
│   └─ 审计能力如何?
│
└─ 业务视角
    ├─ ROI 是什么?
    ├─ 有法律/合规风险吗?
    ├─ 如何影响上市时间?
    └─ 总拥有成本是什么?

Phase 4: 场景探索

探索边缘案例和失败场景:

- [ ] 正常路径: 有效输入的正常操作
- [ ] 无效输入: Null、空、格式错误的数据
- [ ] 边界条件: 最小/最大值、空集合
- [ ] 并发访问: 竞态条件、死锁
- [ ] 规模测试: 10x、100x、1000x 正常负载
- [ ] 网络问题: 超时、部分失败
- [ ] 资源耗尽: 内存、磁盘、连接
- [ ] 安全攻击: 注入、溢出、DoS
- [ ] 数据损坏: 部分写入、不一致
- [ ] 级联失败: 下游服务问题

Step 4: 简化和极简主义审查

运行 Task code-simplicity-reviewer() 看是否可以简化代码

Step 5: 发现综合和待办事项创建

关键要求: 所有发现必须使用 file-todos skill 存储在 todos/ 目录中

5.1 综合所有发现
    ├─ 从所有代理报告收集发现
    ├─ 按类型分类: security, performance, architecture, quality
    ├─ 分配严重性级别: 🔴 P1 (CRITICAL), 🟡 P2 (IMPORTANT), 🔵 P3 (NICE-TO-HAVE)
    ├─ 移除重复或重叠的发现
    └─ 估算每个发现的工作量 (Small/Medium/Large)

5.2 使用 file-todos skill 创建待办事项文件

    实现选项:

    A. 直接文件创建 (快速)
       - 使用 Write 工具直接创建待办文件
       - 所有发现并行以提高速度
       - 使用 .claude/skills/file-todos/assets/todo-template.md 的标准模板
       - 遵循命名约定: {issue_id}-pending-{priority}-{description}.md

    B. 并行子代理 (推荐用于大规模)
       对于有 15+ 发现的大型 PR:
       - 按严重性分组发现 (P1/P2/P3)
       - 启动 3 个并行子代理(每个严重性级别一个)
       - 每个子代理使用 file-todos skill 创建其批次的待办事项
       - 整合结果并呈现摘要

    待办文件结构:
    ---
    status: pending|ready|complete
    priority: p1|p2|p3
    issue_id: [number]
    tags: [code-review, security, performance, ...]
    dependencies: []
    ---

    # [标题]

    ## 问题陈述
    [什么损坏/缺失,为什么重要]

    ## 发现
    [来自代理的发现,带证据/位置]

    ## 建议解决方案
    ### 选项 1: [名称]
    - 优点: [优势]
    - 缺点: [劣势]
    - 工作量: Small/Medium/Large
    - 风险: Low/Medium/High

    ### 选项 2: [名称]
    [同上...]

    ## 推荐行动
    [在分类期间填写,初始留空]

    ## 技术细节
    - 受影响的文件: [文件列表]
    - 组件: [组件列表]
    - 数据库更改: [如适用]

    ## 验收标准
    - [ ] 可测试的标准 1
    - [ ] 可测试的标准 2

    ## 工作日志
    ### YYYY-MM-DD
    - 行动: [采取的行动]
    - 学习: [学到的内容]

    ## 资源
    - PR: #[number]
    - Issues: #[numbers]
    - 文档: [URLs]
    - 类似模式: [文件路径]

    文件命名约定:
    001-pending-p1-security-vulnerability.md
    002-pending-p2-performance-optimization.md
    003-pending-p3-code-cleanup.md

5.3 摘要报告

    创建所有待办文件后,呈现全面摘要:

    ## ✅ 代码审查完成

    **审查目标:** PR #XXXX - [PR 标题]
    **分支:** [branch-name]

    ### 发现摘要:
    - **总发现:** [X]
    - **🔴 CRITICAL (P1):** [count] - 阻止合并
    - **🟡 IMPORTANT (P2):** [count] - 应该修复
    - **🔵 NICE-TO-HAVE (P3):** [count] - 增强

    ### 创建的待办文件:

    **P1 - Critical (阻止合并):**
    - 001-pending-p1-{finding}.md - {描述}
    - 002-pending-p1-{finding}.md - {描述}

    **P2 - Important:**
    - 003-pending-p2-{finding}.md - {描述}
    - 004-pending-p2-{finding}.md - {描述}

    **P3 - Nice-to-Have:**
    - 005-pending-p3-{finding}.md - {描述}

    ### 使用的审查代理:
    - kieran-rails-reviewer
    - security-sentinel
    - performance-oracle
    - architecture-strategist
    - agent-native-reviewer
    - [其他代理]

    ### 下一步:
    1. 处理 P1 发现: CRITICAL - 合并前必须修复
    2. 分类所有待办事项: /triage
    3. 处理批准的待办事项: /resolve_todo_parallel
    4. 跟踪进度: 状态更改时重命名文件

Step 6: 端到端测试 (可选)

检测项目类型:
├─ iOS/macOS: *.xcodeproj, *.xcworkspace, Package.swift
├─ Web: Gemfile, package.json, app/views/*, *.html.*
└─ 混合: 两者都有

提供适当的测试:

FOR Web 项目:
    询问: "想在受影响的页面上运行浏览器测试吗?"
    如接受 → Task general-purpose("运行 /test-browser")

FOR iOS 项目:
    询问: "想在应用上运行 Xcode 模拟器测试吗?"
    如接受 → Task general-purpose("运行 /xcode-test")

FOR 混合项目:
    询问: "想运行端到端测试吗?"
    选项: Web only, iOS only, Both, No
```

### 5.4 优先级级别

```
🔴 P1 (CRITICAL - 阻止合并)
   ├─ 安全漏洞
   ├─ 数据损坏风险
   ├─ 破坏性更改
   └─ 关键架构问题

🟡 P2 (IMPORTANT - 应该修复)
   ├─ 性能问题
   ├─ 重要的架构关注
   ├─ 主要代码质量问题
   └─ 可靠性问题

🔵 P3 (NICE-TO-HAVE)
   ├─ 小改进
   ├─ 代码清理
   ├─ 优化机会
   └─ 文档更新
```

### 5.5 代理调度机制

```
主命令: /workflows:review [PR number]
    ↓
设置审查环境
    ├─ 确定审查目标 (PR/分支/文件)
    ├─ 检查当前分支
    ├─ 提供 worktree 选项 (如需要)
    ├─ 获取 PR 元数据
    └─ 准备分析工具
    ↓
并行代理执行 (最大化效率)
    ├─ 核心审查代理 (12 个同时)
    │   ├─ kieran-rails-reviewer
    │   ├─ dhh-rails-reviewer
    │   ├─ security-sentinel
    │   ├─ performance-oracle
    │   ├─ architecture-strategist
    │   ├─ code-philosopher
    │   ├─ git-history-analyzer
    │   ├─ dependency-detective
    │   ├─ pattern-recognition-specialist
    │   ├─ devops-harmony-analyst
    │   ├─ data-integrity-guardian
    │   └─ agent-native-reviewer
    │
    └─ 条件性代理 (基于 PR 内容)
        ├─ data-migration-expert (如有迁移)
        ├─ deployment-verification-agent (如有迁移)
        └─ rails-turbo-expert (如使用 Turbo)
    ↓
超深度思考分析
    ├─ 利益相关者视角分析
    ├─ 场景探索 (边缘案例、失败场景)
    └─ 简化审查 (code-simplicity-reviewer)
    ↓
发现综合
    ├─ 按类型分类
    ├─ 分配严重性 (P1/P2/P3)
    ├─ 移除重复
    └─ 估算工作量
    ↓
待办事项创建 (并行)
    ├─ 选项 A: 直接文件创建
    │   └─ 快速并行创建所有待办文件
    │
    └─ 选项 B: 并行子代理
        ├─ P1 子代理 → 创建所有 P1 待办事项
        ├─ P2 子代理 → 创建所有 P2 待办事项
        └─ P3 子代理 → 创建所有 P3 待办事项
    ↓
摘要报告
    ├─ 发现统计
    ├─ 创建的待办文件列表
    ├─ 使用的代理
    └─ 下一步建议
    ↓
可选: 端到端测试
    ├─ 检测项目类型
    ├─ 提供测试选项
    └─ 派遣测试子代理 (如接受)
```

### 5.6 file-todos Skill 集成

**关键要求**: 所有审查发现必须使用 file-todos skill 创建为结构化待办文件。

```bash
skill: file-todos
```

**Skill 提供**:
- 模板位置: `.claude/skills/file-todos/assets/todo-template.md`
- 命名约定: `{issue_id}-{status}-{priority}-{description}.md`
- YAML frontmatter 结构: status, priority, issue_id, tags, dependencies
- 所有必需章节: 问题陈述、发现、解决方案等

**状态值**:
- `pending` - 新发现,需要分类/决策
- `ready` - 经理批准,准备工作
- `complete` - 工作完成

**优先级值**:
- `p1` - Critical (阻止合并,安全/数据问题)
- `p2` - Important (应该修复,架构/性能)
- `p3` - Nice-to-have (增强,清理)

---

## 6. 阶段 5: Compound (知识复合)

### 6.1 命令签名

```bash
/workflows:compound [optional: brief context about the fix]
```

### 6.2 核心理念

**每个文档化的解决方案都会复合您团队的知识**

第一次解决"Brief 生成中的 N+1 查询" → 研究(30 分钟)
文档化解决方案 → docs/solutions/performance-issues/n-plus-one-briefs.md (5 分钟)
下次出现类似问题 → 快速查找(2 分钟)
知识复合 → 团队变得更聪明

### 6.3 执行策略: 并行子代理

此命令启动多个专业子代理并行工作以最大化效率:

```
1. 上下文分析器 (并行)
   ├─ 提取对话历史
   ├─ 识别问题类型、组件、症状
   ├─ 对照解决方案架构验证
   └─ 返回: YAML frontmatter 骨架

2. 解决方案提取器 (并行)
   ├─ 分析所有调查步骤
   ├─ 识别根本原因
   ├─ 提取有效解决方案和代码示例
   └─ 返回: 解决方案内容块

3. 相关文档查找器 (并行)
   ├─ 搜索 docs/solutions/ 相关文档
   ├─ 识别交叉引用和链接
   ├─ 查找相关 GitHub issues
   └─ 返回: 链接和关系

4. 预防策略师 (并行)
   ├─ 开发预防策略
   ├─ 创建最佳实践指南
   ├─ 生成测试用例(如适用)
   └─ 返回: 预防/测试内容

5. 类别分类器 (并行)
   ├─ 确定最佳 docs/solutions/ 类别
   ├─ 对照架构验证类别
   ├─ 基于 slug 建议文件名
   └─ 返回: 最终路径和文件名

6. 文档编写器 (并行)
   ├─ 组装完整的 markdown 文件
   ├─ 验证 YAML frontmatter
   ├─ 格式化内容以提高可读性
   └─ 在正确位置创建文件

7. 可选: 专业代理调用 (文档化后)
   基于检测到的问题类型,自动调用适用的代理:

   IF performance_issue
       → performance-oracle

   IF security_issue
       → security-sentinel

   IF database_issue
       → data-integrity-guardian

   IF test_failure
       → cora-test-reviewer

   IF 任何代码密集型问题
       → kieran-rails-reviewer + code-simplicity-reviewer
```

### 6.4 捕获的内容

```
✓ 问题症状
  - 确切的错误消息
  - 可观察的行为

✓ 尝试的调查步骤
  - 什么不起作用以及为什么

✓ 根本原因分析
  - 技术解释

✓ 有效的解决方案
  - 带代码示例的逐步修复

✓ 预防策略
  - 如何在未来避免

✓ 交叉引用
  - 相关 issues 和文档的链接
```

### 6.5 创建的内容

**组织的文档**:

```
文件: docs/solutions/[category]/[filename].md

自动检测的类别:
├─ build-errors/
├─ test-failures/
├─ runtime-errors/
├─ performance-issues/
├─ database-issues/
├─ security-issues/
├─ ui-bugs/
├─ integration-issues/
└─ logic-errors/
```

### 6.6 解决方案文档模板

```markdown
---
title: [问题标题]
category: [auto-detected category]
date: YYYY-MM-DD
tags: [relevant, tags, here]
related_issues: [#123, #456]
---

# [问题标题]

## 症状

[确切的错误消息和可观察行为]

## 根本原因

[技术解释为什么发生]

## 解决方案

### 步骤 1: [描述]

```ruby
# 代码示例
```

### 步骤 2: [描述]

```ruby
# 代码示例
```

## 预防

- [ ] 最佳实践 1
- [ ] 最佳实践 2

## 测试

```ruby
# 测试用例防止回归
```

## 相关资源

- [相关文档](URL)
- [类似问题](URL)
- GitHub Issues: #123, #456
```

### 6.7 成功输出

```
✓ 并行文档生成完成

主子代理结果:
  ✓ 上下文分析器: 在 brief_system 中识别 performance_issue
  ✓ 解决方案提取器: 提取 3 个代码修复
  ✓ 相关文档查找器: 找到 2 个相关 issues
  ✓ 预防策略师: 生成测试用例
  ✓ 类别分类器: docs/solutions/performance-issues/
  ✓ 文档编写器: 创建完整 markdown

专业代理审查 (自动触发):
  ✓ performance-oracle: 验证查询优化方法
  ✓ kieran-rails-reviewer: 代码示例符合 Rails 标准
  ✓ code-simplicity-reviewer: 解决方案适当最小
  ✓ every-style-editor: 文档风格验证

创建的文件:
- docs/solutions/performance-issues/n-plus-one-brief-generation.md

此文档将可搜索,以供将来在邮件处理或 Brief 系统模块中出现类似问题时参考。

接下来做什么?
1. 继续工作流 (推荐)
2. 链接相关文档
3. 更新其他引用
4. 查看文档
5. 其他
```

### 6.8 复合哲学

```
构建 → 测试 → 发现问题 → 研究 → 改进 → 文档化 → 验证 → 部署
    ↑                                                              ↓
    └──────────────────────────────────────────────────────────────┘
```

**每单位工程工作应该使后续工作单元更容易 - 而不是更难。**

### 6.9 适用的专业代理

基于问题类型,这些代理可以增强文档:

**代码质量与审查**:
- kieran-rails-reviewer: 审查 Rails 最佳实践的代码示例
- code-simplicity-reviewer: 确保解决方案代码最小且清晰
- pattern-recognition-specialist: 识别反模式或重复问题

**特定领域专家**:
- performance-oracle: 分析 performance_issue 类别解决方案
- security-sentinel: 审查 security_issue 解决方案的漏洞
- cora-test-reviewer: 为预防策略创建测试用例
- data-integrity-guardian: 审查 database_issue 迁移和查询

**增强与文档**:
- best-practices-researcher: 用行业最佳实践丰富解决方案
- every-style-editor: 审查文档风格和清晰度
- framework-docs-researcher: 链接到 Rails/gem 文档引用

---

## 7. 代理调度系统

### 7.1 调度架构

```
命令层 (5 个工作流命令)
    ↓
调度决策引擎
    ↓
代理池 (27 个专业代理)
    ├─ Review (14)
    ├─ Research (4)
    ├─ Design (3)
    ├─ Workflow (5)
    └─ Docs (1)
    ↓
执行与结果聚合
```

### 7.2 并行调度策略

**为什么并行?**
- ✅ 最大化吞吐量
- ✅ 减少总执行时间
- ✅ 利用多核处理
- ✅ 提高响应性

**调度模式**:

```javascript
// 模式 1: 独立并行
Task(agent-A)(input-A)
Task(agent-B)(input-B)
Task(agent-C)(input-C)
// 所有代理同时运行

// 模式 2: 条件并行
IF condition-met
    Task(agent-D)(input-D)
    Task(agent-E)(input-E)

// 模式 3: 顺序依赖
results-A = Task(agent-A)(input)
results-B = Task(agent-B)(results-A)  // 依赖 A
```

### 7.3 代理专业化矩阵

| 工作流阶段 | 主代理 | 辅助代理 | 条件代理 |
|----------|--------|---------|---------|
| **Brainstorm** | repo-research-analyst | - | - |
| **Plan** | repo-research-analyst, learnings-researcher | best-practices-researcher, framework-docs-researcher | spec-flow-analyzer |
| **Work** | - | code-simplicity-reviewer, kieran-rails-reviewer | performance-oracle, security-sentinel |
| **Review** | kieran-rails-reviewer, security-sentinel, performance-oracle | architecture-strategist, code-philosopher | data-migration-expert, deployment-verification-agent |
| **Compound** | 6 个并行子代理 | performance-oracle, kieran-rails-reviewer | 基于问题类型的专业代理 |

### 7.4 调度决策树

```
/workflows:brainstorm
    → 派遣: repo-research-analyst
    → 目的: 查找现有模式
    → 并行: 否 (单一轻量级研究)

/workflows:plan
    → 派遣: repo-research-analyst + learnings-researcher (并行)
    → 决策: 需要外部研究?
        IF 是 → 派遣: best-practices-researcher + framework-docs-researcher (并行)
        IF 否 → 跳过
    → 最终: spec-flow-analyzer (顺序)

/workflows:work
    → 主执行: 主代理遵循计划
    → 可选审查: 仅用于复杂/风险高的更改
        - code-simplicity-reviewer
        - kieran-rails-reviewer
        - performance-oracle
        - security-sentinel

/workflows:review
    → 核心审查: 12 个代理并行
    → 条件审查: 基于 PR 内容
        IF 迁移 → data-migration-expert + deployment-verification-agent
        IF Turbo → rails-turbo-expert
    → 待办创建: 并行子代理(P1/P2/P3)

/workflows:compound
    → 6 个并行子代理:
        1. 上下文分析器
        2. 解决方案提取器
        3. 相关文档查找器
        4. 预防策略师
        5. 类别分类器
        6. 文档编写器
    → 后处理: 基于问题类型的专业代理
```

---

## 8. 工作流自动化与编排

### 8.1 工作流链接

```
自动工作流链:

/workflows:brainstorm
    ↓
询问: "继续规划?"
    ↓ (如果是)
/workflows:plan
    ↓
提供选项:
1. /workflows:work (本地)
2. /workflows:work & (远程)
3. /deepen-plan
4. /plan_review
    ↓ (选择 work)
/workflows:work
    ↓
创建 PR
    ↓
自动建议:
/workflows:review [PR number]
    ↓
生成待办事项
    ↓
建议:
/triage (分类待办)
/resolve_todo_parallel (修复)
    ↓
问题解决后
    ↓
自动触发:
/workflows:compound
```

### 8.2 自动触发器

**Compound 自动调用**:

```yaml
触发短语:
  - "that worked"
  - "it's fixed"
  - "working now"
  - "problem solved"

触发条件:
  - 问题已解决(非进行中)
  - 解决方案已验证有效
  - 非平凡问题(非简单拼写错误)

行为:
  自动运行 /workflows:compound [context]
```

### 8.3 工作流检查点

每个阶段都有明确的检查点:

```
Brainstorm 检查点:
  ├─ 设计文档创建
  └─ 用户批准继续

Plan 检查点:
  ├─ 计划文档创建
  ├─ 研究完成
  └─ 用户选择详细程度

Work 检查点:
  ├─ 增量提交 (每逻辑单元)
  ├─ 测试通过验证
  ├─ 质量检查通过
  └─ PR 创建

Review 检查点:
  ├─ 所有代理完成
  ├─ 发现综合
  ├─ 待办创建
  └─ P1 发现必须修复

Compound 检查点:
  ├─ 所有子代理完成
  ├─ 文档创建
  └─ 专业代理验证
```

---

## 9. 完整示例: 从需求到知识捕获

### 9.1 场景

用户请求: "为我的电商应用添加产品评论功能"

### 9.2 执行流程

#### 步骤 1: Brainstorm

```
[用户] /workflows:brainstorm 添加产品评论功能

[Claude]
检测到功能描述。开始探索...

[派遣 repo-research-analyst]
Task repo-research-analyst("理解电商应用现有模式")

[研究结果]
- 找到现有的评分系统 (app/models/rating.rb)
- 发现用户认证模式 (Devise)
- 识别产品模型结构

[协作对话]
Q1: "评论应该支持哪些功能?"
选项:
  1. 基本文本评论
  2. 带评分的评论 (1-5 星)
  3. 带评分和图片的评论

用户选择: 2

Q2: "评论应该允许编辑吗?"
选项:
  1. 是,无时间限制
  2. 是,仅在 24 小时内
  3. 否,一旦发布就不能编辑

用户选择: 2

Q3: "如何处理垃圾评论?"
选项:
  1. 管理员审核所有评论
  2. 用户可以举报垃圾评论
  3. 自动垃圾检测

用户选择: 2

[探索方案]
方案 A: 嵌套在 Product 模型中 (推荐)
- 简单,遵循 Rails 约定
- 易于查询和显示
- 已有类似模式(评分)

方案 B: 独立评论系统
- 更灵活,但更复杂
- 不适合当前应用规模

方案 C: 第三方评论服务
- 快速,但增加依赖和成本

推荐: 方案 A (嵌套模型)

[设计文档创建]
写入: docs/brainstorms/2026-01-31-product-reviews-brainstorm.md

[交接]
设计探索完成!

文档: docs/brainstorms/2026-01-31-product-reviews-brainstorm.md

关键决策:
- 带评分的文本评论 (1-5 星)
- 24 小时内可编辑
- 用户举报垃圾评论
- 嵌套在 Product 模型

接下来做什么?
1. 继续规划 - 运行 /workflows:plan
2. 进一步细化 - 继续探索
3. 暂时完成

用户选择: 1
```

#### 步骤 2: Plan

```
[Claude]
找到设计文档: 2026-01-31-product-reviews-brainstorm.md
使用设计文档作为计划的上下文。跳过细化问题。

[并行本地研究]
Task repo-research-analyst(产品评论功能)
Task learnings-researcher(产品评论功能)

[研究结果]
repo-research:
- 现有评分系统: app/models/rating.rb (参考实现)
- 用户认证: Devise (已设置)
- 验证模式: 使用 ActiveModel::Validations
- CLAUDE.md: 使用 TDD,遵循 Rails 约定

learnings-research:
- docs/solutions/: 找到"垃圾内容检测最佳实践"
- 建议: 速率限制 + 内容过滤

[研究决策]
强本地上下文(良好模式、CLAUDE.md 指南)。
无外部研究继续。

[SpecFlow 分析]
Task spec-flow-analyzer(功能描述, 研究发现)

SpecFlow 发现:
- 需要考虑: 删除产品时的评论处理
- 建议添加: 评论审核状态(待审/批准/垃圾)
- 边缘案例: 未登录用户尝试评论

[选择详细程度]
建议: MORE (标准 Issue)
原因: 中等复杂度,团队协作,需要详细说明

[计划创建]
写入: docs/plans/2026-01-31-feat-product-reviews-plan.md

[生成后选项]
计划已就绪: docs/plans/2026-01-31-feat-product-reviews-plan.md

接下来做什么?
1. 在编辑器中打开计划
2. 运行 /deepen-plan
3. 运行 /plan_review
4. 启动 /workflows:work
5. 在远程启动 /workflows:work
6. 创建 Issue
7. 简化

用户选择: 4
```

#### 步骤 3: Work

```
[Claude]
读取计划: docs/plans/2026-01-31-feat-product-reviews-plan.md

计划包含:
- 12 个任务
- 估计时间: 2-3 小时
- 参考文件: app/models/rating.rb, app/models/product.rb

[澄清问题]
所有内容都清楚。准备继续。

[设置环境]
当前分支: main
建议: 创建功能分支

git checkout -b feat/product-reviews

[创建待办列表]
使用 TodoWrite 创建 12 个任务:
1. 生成 Review 模型
2. 添加关联到 Product
3. 添加验证
4. 创建 ReviewsController
5. 添加路由
6. 创建审查视图
7. 添加编辑功能(24 小时限制)
8. 添加举报功能
9. 添加速率限制
10. 编写测试
11. 添加垃圾检测
12. 更新文档

[执行循环]
任务 1: 生成 Review 模型
├─ 参考: app/models/rating.rb
├─ 生成: rails g model Review product:references user:references rating:integer content:text
├─ 运行迁移: rails db:migrate
├─ 测试: rails test
└─ 增量提交:
    git add db/migrate/* app/models/review.rb test/models/review_test.rb
    git commit -m "feat(reviews): add Review model with associations"

任务 2: 添加关联到 Product
├─ 编辑: app/models/product.rb
    has_many :reviews, dependent: :destroy
├─ 编辑: app/models/review.rb
    belongs_to :product
    belongs_to :user
├─ 测试: rails test
└─ 增量提交:
    git add app/models/product.rb app/models/review.rb test/models/*
    git commit -m "feat(reviews): add Product-Review associations"

[... 任务 3-12 类似执行 ...]

[质量检查]
运行完整测试套件:
rails test
✓ 48 tests, 0 failures

运行 linting:
使用 linting-agent
✓ 无问题

[可选审查] (跳过 - 不是复杂更改)

[最终提交]
git add .
git commit -m "$(cat <<'EOF'
feat(reviews): add product review system with moderation

- Reviews with 1-5 star ratings
- 24-hour edit window
- User report spam feature
- Rate limiting and content filtering

🤖 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"

[捕获截图]
bin/dev  # 启动服务器

agent-browser open http://localhost:3000/products/1
agent-browser snapshot -i
agent-browser screenshot review-form.png

agent-browser open http://localhost:3000/products/1#reviews
agent-browser screenshot review-list.png

skill: imgup
imgup -h pixhost review-form.png
→ https://pixhost.com/show/abc123

imgup -h pixhost review-list.png
→ https://pixhost.com/show/def456

[创建 PR]
git push -u origin feat/product-reviews

gh pr create --title "feat: Add product review system" --body "$(cat <<'EOF'
## 摘要
- 为产品添加评论系统
- 支持 1-5 星评分
- 24 小时编辑窗口
- 用户举报垃圾功能
- 速率限制和内容过滤

## 测试
- 48 个测试全部通过
- 手动测试: 创建、编辑、删除评论
- 手动测试: 举报垃圾评论功能

## 截图
| 评论表单 | 评论列表 |
|---------|---------|
| ![form](https://pixhost.com/show/abc123) | ![list](https://pixhost.com/show/def456) |

## 参考
- 设计: docs/brainstorms/2026-01-31-product-reviews-brainstorm.md
- 计划: docs/plans/2026-01-31-feat-product-reviews-plan.md

---

[![Compound Engineered](https://img.shields.io/badge/Compound-Engineered-6366f1)](https://github.com/EveryInc/compound-engineering-plugin) 🤖 Generated with [Claude Code](https://claude.com/claude-code)
EOF
)"

PR 创建: https://github.com/user/ecommerce-app/pull/123

[通知用户]
✅ 产品评论系统完成!

完成内容:
- 所有 12 个任务已完成
- 48 个测试通过
- PR #123 创建

下一步:
运行 /workflows:review 123 进行全面审查
```

#### 步骤 4: Review

```
[用户] /workflows:review 123

[Claude]
启动 PR #123 的全面审查...

[设置]
当前分支: feat/product-reviews (已在目标分支)
继续在当前分支分析。

[获取 PR 元数据]
gh pr view 123 --json title,body,files

PR 标题: feat: Add product review system
受影响的文件: 24 个文件

[并行核心审查代理]
Task kieran-rails-reviewer(PR #123)
Task dhh-rails-reviewer(PR #123)
Task security-sentinel(PR #123)
Task performance-oracle(PR #123)
Task architecture-strategist(PR #123)
Task code-philosopher(PR #123)
Task git-history-analyzer(PR #123)
Task dependency-detective(PR #123)
Task pattern-recognition-specialist(PR #123)
Task devops-harmony-analyst(PR #123)
Task data-integrity-guardian(PR #123)
Task agent-native-reviewer(PR #123)

[条件代理]
无迁移文件 → 跳过 data-migration-expert
无 Turbo 使用 → 跳过 rails-turbo-expert

[代理结果汇总]
kieran-rails-reviewer:
  ✓ 遵循 Rails 约定
  ⚠️ 建议添加数据库索引到 reviews.product_id

dhh-rails-reviewer:
  ✓ 模型关联干净
  ✓ 控制器遵循 RESTful 模式

security-sentinel:
  🔴 发现 1: 速率限制可绕过(使用不同 IP)
  🟡 发现 2: 需要内容 XSS 清理

performance-oracle:
  🟡 发现 3: 缺少 product_id 和 user_id 索引
  🔵 发现 4: 考虑评论分页(未来)

architecture-strategist:
  ✓ 设计干净且可扩展
  🔵 发现 5: 考虑提取 SpamDetection 服务

... [其他代理结果] ...

[简化审查]
Task code-simplicity-reviewer(PR #123)
  ✓ 代码简洁,无过度工程

[发现综合]
总发现: 5
├─ P1 (CRITICAL): 1
│   └─ 速率限制可绕过
├─ P2 (IMPORTANT): 2
│   ├─ 缺少 XSS 清理
│   └─ 缺少数据库索引
└─ P3 (NICE-TO-HAVE): 2
    ├─ 评论分页
    └─ 提取 SpamDetection 服务

[并行待办创建]
使用 file-todos skill:

P1 子代理:
  创建: 001-pending-p1-rate-limit-bypass.md

P2 子代理:
  创建: 002-pending-p2-xss-sanitization.md
  创建: 003-pending-p2-missing-db-indexes.md

P3 子代理:
  创建: 004-pending-p3-review-pagination.md
  创建: 005-pending-p3-extract-spam-service.md

[摘要报告]
## ✅ 代码审查完成

**审查目标:** PR #123 - feat: Add product review system
**分支:** feat/product-reviews

### 发现摘要:
- **总发现:** 5
- **🔴 CRITICAL (P1):** 1 - 阻止合并
- **🟡 IMPORTANT (P2):** 2 - 应该修复
- **🔵 NICE-TO-HAVE (P3):** 2 - 增强

### 创建的待办文件:

**P1 - Critical (阻止合并):**
- 001-pending-p1-rate-limit-bypass.md - 速率限制可使用不同 IP 绕过

**P2 - Important:**
- 002-pending-p2-xss-sanitization.md - 评论内容需要 XSS 清理
- 003-pending-p2-missing-db-indexes.md - reviews 表缺少索引

**P3 - Nice-to-Have:**
- 004-pending-p3-review-pagination.md - 考虑为大量评论添加分页
- 005-pending-p3-extract-spam-service.md - 提取垃圾检测到服务对象

### 使用的审查代理:
- kieran-rails-reviewer
- dhh-rails-reviewer
- security-sentinel
- performance-oracle
- architecture-strategist
- code-philosopher
- git-history-analyzer
- dependency-detective
- pattern-recognition-specialist
- devops-harmony-analyst
- data-integrity-guardian
- agent-native-reviewer

### 下一步:
1. **处理 P1 发现**: CRITICAL - 合并前必须修复
2. **分类所有待办**: `/triage`
3. **处理批准的待办**: `/resolve_todo_parallel`
4. **跟踪进度**: 状态更改时重命名文件

[端到端测试提议]
检测到 Web 项目 (app/views/*)

想在受影响的页面上运行浏览器测试吗?
1. 是 - 运行 /test-browser
2. 否 - 跳过

用户选择: 2 (跳过)
```

#### 步骤 5: 解决审查发现并修复

```
[用户] /triage

[分类会话]
001-pending-p1-rate-limit-bypass.md
  决策: 批准 - 移动到 001-ready-p1-rate-limit-bypass.md

002-pending-p2-xss-sanitization.md
  决策: 批准 - 移动到 002-ready-p2-xss-sanitization.md

003-pending-p2-missing-db-indexes.md
  决策: 批准 - 移动到 003-ready-p2-missing-db-indexes.md

004-pending-p3-review-pagination.md
  决策: 延期 - 未来版本

005-pending-p3-extract-spam-service.md
  决策: 延期 - 未来重构

[用户] /resolve_todo_parallel

[修复待办]
任务 1: 修复速率限制绕过
├─ 实现: 基于用户的速率限制(不是 IP)
├─ 测试: 添加速率限制测试
└─ 提交: git commit -m "fix(reviews): use user-based rate limiting"

任务 2: 添加 XSS 清理
├─ 实现: 在 Review 模型中使用 sanitize
├─ 测试: 添加 XSS 测试
└─ 提交: git commit -m "fix(reviews): sanitize content for XSS"

任务 3: 添加数据库索引
├─ 迁移: rails g migration AddIndexesToReviews
├─ 测试: 验证索引
└─ 提交: git commit -m "perf(reviews): add indexes to reviews table"

所有待办已解决!

git push origin feat/product-reviews

PR #123 已更新并准备合并!
```

#### 步骤 6: Compound

```
[问题解决后]

[Claude 自动检测]
检测到问题解决短语: "All todos resolved!"
自动触发 /workflows:compound

[并行子代理]
1. Task context-analyzer(对话历史)
   → 识别: security_issue (速率限制绕过)
   → 返回: YAML frontmatter

2. Task solution-extractor(调查步骤)
   → 根本原因: 基于 IP 的速率限制不可靠
   → 解决方案: 基于用户的速率限制
   → 返回: 解决方案内容

3. Task related-docs-finder()
   → 搜索: docs/solutions/security-issues/
   → 找到: 0 个相关文档
   → 返回: 空链接

4. Task prevention-strategist()
   → 策略: 始终对用户操作使用用户标识符
   → 测试: 添加速率限制测试用例
   → 返回: 预防内容

5. Task category-classifier()
   → 分类: security-issues
   → 文件名: rate-limit-bypass-user-based.md
   → 返回: 路径

6. Task documentation-writer()
   → 组装: 完整 markdown
   → 验证: YAML frontmatter
   → 创建: docs/solutions/security-issues/rate-limit-bypass-user-based.md

[专业代理审查]
Task security-sentinel(文档)
  ✓ 解决方案安全且正确

Task kieran-rails-reviewer(代码示例)
  ✓ 代码遵循 Rails 约定

Task code-simplicity-reviewer(解决方案)
  ✓ 解决方案简洁

Task every-style-editor(文档)
  ✓ 文档风格清晰

[输出]
✓ 并行文档生成完成

主子代理结果:
  ✓ 上下文分析器: 识别 security_issue
  ✓ 解决方案提取器: 提取基于用户的速率限制修复
  ✓ 相关文档查找器: 未找到先前文档
  ✓ 预防策略师: 生成最佳实践
  ✓ 类别分类器: docs/solutions/security-issues/
  ✓ 文档编写器: 创建完整 markdown

专业代理审查 (自动触发):
  ✓ security-sentinel: 验证安全方法
  ✓ kieran-rails-reviewer: 代码示例符合 Rails 标准
  ✓ code-simplicity-reviewer: 解决方案简洁
  ✓ every-style-editor: 文档风格验证

创建的文件:
- docs/solutions/security-issues/rate-limit-bypass-user-based.md

此文档将可搜索,以供将来在速率限制实现中出现类似问题时参考。

接下来做什么?
1. 继续工作流 (推荐)
2. 链接相关文档
3. 更新其他引用
4. 查看文档
5. 其他

用户选择: 1 (继续)
```

### 9.3 时间线总结

| 阶段 | 时间 | 累计 |
|------|------|------|
| Brainstorm | 10 分钟 | 10 分钟 |
| Plan | 15 分钟 | 25 分钟 |
| Work (12 任务) | 2.5 小时 | 175 分钟 |
| Review (12 代理并行) | 8 分钟 | 183 分钟 |
| 修复审查发现 | 30 分钟 | 213 分钟 |
| Compound | 5 分钟 | 218 分钟 |

**总计**: ~3.6 小时(从需求到知识复合)

### 9.4 创建的工件

```
docs/
├─ brainstorms/
│  └─ 2026-01-31-product-reviews-brainstorm.md
│
├─ plans/
│  └─ 2026-01-31-feat-product-reviews-plan.md
│
└─ solutions/
   └─ security-issues/
      └─ rate-limit-bypass-user-based.md

todos/
├─ 001-complete-p1-rate-limit-bypass.md
├─ 002-complete-p2-xss-sanitization.md
├─ 003-complete-p2-missing-db-indexes.md
├─ 004-pending-p3-review-pagination.md
└─ 005-pending-p3-extract-spam-service.md

GitHub:
└─ PR #123 (已合并)
```

---

## 10. 工作流最佳实践

### 10.1 何时使用哪个工作流

```
遇到场景:
  ├─ 不明确的需求 / 探索性工作 → /workflows:brainstorm
  ├─ 明确的功能 / Bug 修复 → /workflows:plan
  ├─ 有批准的计划 → /workflows:work
  ├─ PR 已创建 → /workflows:review
  ├─ 问题已解决 → /workflows:compound
  ├─ 需要深化计划 → /deepen-plan
  ├─ 需要计划审查 → /plan_review
  ├─ 需要分类待办 → /triage
  └─ 需要修复待办 → /resolve_todo_parallel
```

### 10.2 工作流组合模式

**模式 1: 快速功能开发**
```
/workflows:plan (MINIMAL) → /workflows:work → /workflows:review
```
适用于: 简单功能、小改进、清晰需求

**模式 2: 标准功能开发**
```
/workflows:brainstorm → /workflows:plan (MORE) → /workflows:work → /workflows:review → /workflows:compound
```
适用于: 大多数功能、中等复杂度、团队协作

**模式 3: 重大功能开发**
```
/workflows:brainstorm → /workflows:plan (A LOT) → /deepen-plan → /plan_review → /workflows:work → /workflows:review → /triage → /resolve_todo_parallel → /workflows:compound
```
适用于: 主要功能、架构变更、高风险项目

**模式 4: Bug 修复**
```
/workflows:plan (MINIMAL) → /workflows:work → /workflows:compound
```
适用于: 简单 bugs、已知根因

**模式 5: 复杂 Bug 调试**
```
调试 → /workflows:compound → /workflows:review (如有代码更改)
```
适用于: 复杂 bugs、未知根因、需要文档化

### 10.3 常见陷阱与避免方法

| 陷阱 | 后果 | 避免方法 |
|------|------|---------|
| **跳过 Brainstorm** | 需求不明、返工 | 对不明确需求始终使用 brainstorm |
| **过度规划** | 分析瘫痪、时间浪费 | 选择合适的计划详细程度 (MINIMAL/MORE/A LOT) |
| **规划不足** | 执行困难、时间超预期 | 对复杂功能使用 MORE 或 A LOT 模板 |
| **跳过研究** | 重新发明轮子、错过最佳实践 | 信任自动研究决策逻辑 |
| **过度研究** | 时间浪费、信息过载 | 高风险主题才进行外部研究 |
| **跳过增量提交** | 大爆炸提交、难以审查 | 每逻辑单元提交 |
| **过度提交** | 提交历史噪音 | 仅在有意义进展时提交 |
| **跳过质量检查** | PR 中的 bugs、审查发现多 | 始终运行测试 + linting |
| **过度审查简单更改** | 浪费时间、代理疲劳 | 仅对复杂/风险高更改使用审查代理 |
| **忽略 P1 发现** | 合并有问题的代码、生产问题 | P1 发现阻止合并 - 必须修复 |
| **跳过 Compound** | 知识丢失、重复工作 | 问题解决后文档化学习 |
| **延迟 Compound** | 上下文丢失、文档质量差 | 问题解决后立即使用 compound |

### 10.4 效率优化技巧

**1. 利用并行执行**
```
✅ 并行运行独立代理
Task(agent-A)(input-A)
Task(agent-B)(input-B)
Task(agent-C)(input-C)

❌ 顺序运行独立代理
results-A = agent-A(input)
results-B = agent-B(input)
results-C = agent-C(input)
```

**2. 选择合适的详细程度**
```
简单 Bug → MINIMAL (节省时间)
标准功能 → MORE (平衡)
复杂功能 → A LOT (彻底)
```

**3. 重用现有知识**
```
- 检查 docs/solutions/ 相关解决方案
- 参考 docs/brainstorms/ 先前设计
- 查看 docs/plans/ 类似计划
- 遵循 CLAUDE.md 约定
```

**4. 自动化重复任务**
```
- 使用 TodoWrite 跟踪进度
- 使用 file-todos skill 结构化待办
- 使用 /resolve_todo_parallel 批量修复
- 使用自动触发器 (compound)
```

**5. 质量内建**
```
- 持续测试 (边开发边测试)
- 遵循现有模式 (减少审查发现)
- 增量提交 (易于审查和回滚)
- 为 UI 更改捕获截图
```

### 10.5 成功指标

**Brainstorm 成功**:
- ✓ 需求清晰且有文档
- ✓ 方案已评估并选择
- ✓ 关键决策已记录
- ✓ 用户批准继续

**Plan 成功**:
- ✓ 可操作的任务列表
- ✓ 明确的验收标准
- ✓ 相关研究整合
- ✓ 适当的详细程度

**Work 成功**:
- ✓ 所有任务完成
- ✓ 所有测试通过
- ✓ 代码遵循模式
- ✓ PR 创建并带截图

**Review 成功**:
- ✓ 所有代理执行
- ✓ 发现已分类 (P1/P2/P3)
- ✓ 待办已创建
- ✓ P1 发现已识别

**Compound 成功**:
- ✓ 解决方案已文档化
- ✓ 预防策略已捕获
- ✓ 相关资源已链接
- ✓ 可搜索和可发现

---

## 11. 总结

Compound Engineering Plugin 的核心工作流是一个 **系统化、可验证、知识复合** 的 AI 驱动开发流程。

它通过:

1. **需求探索优先** (Brainstorm) - 在编码前理解
2. **研究驱动规划** (Plan) - 基于证据的决策
3. **质量内建执行** (Work) - 边开发边测试
4. **穷尽式审查** (Review) - 多代理并行分析
5. **知识复合** (Compound) - 使每次工作更容易

确保:
- ✅ 每一行代码都有明确的理由
- ✅ 每个决策都有研究支持
- ✅ 每个功能都有全面的测试
- ✅ 每个问题都被文档化为知识
- ✅ 每次工作让未来工作更容易

**这不是"快速交付",而是"复合工程"。**
**这不是"一次性工具",而是"知识系统"。**

**Compound Engineering Plugin 让 AI 代理拥有真正的"复合能力" - 系统化、知识化、高质量的软件开发流程。**
